// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.3
// source: levels.proto

package levels

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	LevelService_GetUserLevel_FullMethodName        = "/levels.LevelService/GetUserLevel"
	LevelService_GetAllLevels_FullMethodName        = "/levels.LevelService/GetAllLevels"
	LevelService_GetLevel_FullMethodName            = "/levels.LevelService/GetLevel"
	LevelService_GetLevelGeneralInfo_FullMethodName = "/levels.LevelService/GetLevelGeneralInfo"
	LevelService_GetLevelGem_FullMethodName         = "/levels.LevelService/GetLevelGem"
	LevelService_GetLevelGift_FullMethodName        = "/levels.LevelService/GetLevelGift"
	LevelService_GetLevelLicenses_FullMethodName    = "/levels.LevelService/GetLevelLicenses"
	LevelService_GetLevelPrizes_FullMethodName      = "/levels.LevelService/GetLevelPrizes"
	LevelService_ClaimPrize_FullMethodName          = "/levels.LevelService/ClaimPrize"
)

// LevelServiceClient is the client API for LevelService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// LevelService handles user level progression
type LevelServiceClient interface {
	GetUserLevel(ctx context.Context, in *GetUserLevelRequest, opts ...grpc.CallOption) (*UserLevelResponse, error)
	GetAllLevels(ctx context.Context, in *GetAllLevelsRequest, opts ...grpc.CallOption) (*LevelsResponse, error)
	GetLevel(ctx context.Context, in *GetLevelRequest, opts ...grpc.CallOption) (*LevelResponse, error)
	GetLevelGeneralInfo(ctx context.Context, in *GetLevelGeneralInfoRequest, opts ...grpc.CallOption) (*LevelGeneralInfoResponse, error)
	GetLevelGem(ctx context.Context, in *GetLevelGemRequest, opts ...grpc.CallOption) (*LevelGemResponse, error)
	GetLevelGift(ctx context.Context, in *GetLevelGiftRequest, opts ...grpc.CallOption) (*LevelGiftResponse, error)
	GetLevelLicenses(ctx context.Context, in *GetLevelLicensesRequest, opts ...grpc.CallOption) (*LevelLicensesResponse, error)
	GetLevelPrizes(ctx context.Context, in *GetLevelPrizesRequest, opts ...grpc.CallOption) (*LevelPrizesResponse, error)
	ClaimPrize(ctx context.Context, in *ClaimPrizeRequest, opts ...grpc.CallOption) (*ClaimPrizeResponse, error)
}

type levelServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewLevelServiceClient(cc grpc.ClientConnInterface) LevelServiceClient {
	return &levelServiceClient{cc}
}

func (c *levelServiceClient) GetUserLevel(ctx context.Context, in *GetUserLevelRequest, opts ...grpc.CallOption) (*UserLevelResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserLevelResponse)
	err := c.cc.Invoke(ctx, LevelService_GetUserLevel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *levelServiceClient) GetAllLevels(ctx context.Context, in *GetAllLevelsRequest, opts ...grpc.CallOption) (*LevelsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LevelsResponse)
	err := c.cc.Invoke(ctx, LevelService_GetAllLevels_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *levelServiceClient) GetLevel(ctx context.Context, in *GetLevelRequest, opts ...grpc.CallOption) (*LevelResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LevelResponse)
	err := c.cc.Invoke(ctx, LevelService_GetLevel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *levelServiceClient) GetLevelGeneralInfo(ctx context.Context, in *GetLevelGeneralInfoRequest, opts ...grpc.CallOption) (*LevelGeneralInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LevelGeneralInfoResponse)
	err := c.cc.Invoke(ctx, LevelService_GetLevelGeneralInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *levelServiceClient) GetLevelGem(ctx context.Context, in *GetLevelGemRequest, opts ...grpc.CallOption) (*LevelGemResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LevelGemResponse)
	err := c.cc.Invoke(ctx, LevelService_GetLevelGem_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *levelServiceClient) GetLevelGift(ctx context.Context, in *GetLevelGiftRequest, opts ...grpc.CallOption) (*LevelGiftResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LevelGiftResponse)
	err := c.cc.Invoke(ctx, LevelService_GetLevelGift_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *levelServiceClient) GetLevelLicenses(ctx context.Context, in *GetLevelLicensesRequest, opts ...grpc.CallOption) (*LevelLicensesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LevelLicensesResponse)
	err := c.cc.Invoke(ctx, LevelService_GetLevelLicenses_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *levelServiceClient) GetLevelPrizes(ctx context.Context, in *GetLevelPrizesRequest, opts ...grpc.CallOption) (*LevelPrizesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LevelPrizesResponse)
	err := c.cc.Invoke(ctx, LevelService_GetLevelPrizes_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *levelServiceClient) ClaimPrize(ctx context.Context, in *ClaimPrizeRequest, opts ...grpc.CallOption) (*ClaimPrizeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClaimPrizeResponse)
	err := c.cc.Invoke(ctx, LevelService_ClaimPrize_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LevelServiceServer is the server API for LevelService service.
// All implementations must embed UnimplementedLevelServiceServer
// for forward compatibility.
//
// LevelService handles user level progression
type LevelServiceServer interface {
	GetUserLevel(context.Context, *GetUserLevelRequest) (*UserLevelResponse, error)
	GetAllLevels(context.Context, *GetAllLevelsRequest) (*LevelsResponse, error)
	GetLevel(context.Context, *GetLevelRequest) (*LevelResponse, error)
	GetLevelGeneralInfo(context.Context, *GetLevelGeneralInfoRequest) (*LevelGeneralInfoResponse, error)
	GetLevelGem(context.Context, *GetLevelGemRequest) (*LevelGemResponse, error)
	GetLevelGift(context.Context, *GetLevelGiftRequest) (*LevelGiftResponse, error)
	GetLevelLicenses(context.Context, *GetLevelLicensesRequest) (*LevelLicensesResponse, error)
	GetLevelPrizes(context.Context, *GetLevelPrizesRequest) (*LevelPrizesResponse, error)
	ClaimPrize(context.Context, *ClaimPrizeRequest) (*ClaimPrizeResponse, error)
	mustEmbedUnimplementedLevelServiceServer()
}

// UnimplementedLevelServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedLevelServiceServer struct{}

func (UnimplementedLevelServiceServer) GetUserLevel(context.Context, *GetUserLevelRequest) (*UserLevelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserLevel not implemented")
}
func (UnimplementedLevelServiceServer) GetAllLevels(context.Context, *GetAllLevelsRequest) (*LevelsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllLevels not implemented")
}
func (UnimplementedLevelServiceServer) GetLevel(context.Context, *GetLevelRequest) (*LevelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLevel not implemented")
}
func (UnimplementedLevelServiceServer) GetLevelGeneralInfo(context.Context, *GetLevelGeneralInfoRequest) (*LevelGeneralInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLevelGeneralInfo not implemented")
}
func (UnimplementedLevelServiceServer) GetLevelGem(context.Context, *GetLevelGemRequest) (*LevelGemResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLevelGem not implemented")
}
func (UnimplementedLevelServiceServer) GetLevelGift(context.Context, *GetLevelGiftRequest) (*LevelGiftResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLevelGift not implemented")
}
func (UnimplementedLevelServiceServer) GetLevelLicenses(context.Context, *GetLevelLicensesRequest) (*LevelLicensesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLevelLicenses not implemented")
}
func (UnimplementedLevelServiceServer) GetLevelPrizes(context.Context, *GetLevelPrizesRequest) (*LevelPrizesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLevelPrizes not implemented")
}
func (UnimplementedLevelServiceServer) ClaimPrize(context.Context, *ClaimPrizeRequest) (*ClaimPrizeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClaimPrize not implemented")
}
func (UnimplementedLevelServiceServer) mustEmbedUnimplementedLevelServiceServer() {}
func (UnimplementedLevelServiceServer) testEmbeddedByValue()                      {}

// UnsafeLevelServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LevelServiceServer will
// result in compilation errors.
type UnsafeLevelServiceServer interface {
	mustEmbedUnimplementedLevelServiceServer()
}

func RegisterLevelServiceServer(s grpc.ServiceRegistrar, srv LevelServiceServer) {
	// If the following call pancis, it indicates UnimplementedLevelServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&LevelService_ServiceDesc, srv)
}

func _LevelService_GetUserLevel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserLevelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LevelServiceServer).GetUserLevel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LevelService_GetUserLevel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LevelServiceServer).GetUserLevel(ctx, req.(*GetUserLevelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LevelService_GetAllLevels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAllLevelsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LevelServiceServer).GetAllLevels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LevelService_GetAllLevels_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LevelServiceServer).GetAllLevels(ctx, req.(*GetAllLevelsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LevelService_GetLevel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLevelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LevelServiceServer).GetLevel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LevelService_GetLevel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LevelServiceServer).GetLevel(ctx, req.(*GetLevelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LevelService_GetLevelGeneralInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLevelGeneralInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LevelServiceServer).GetLevelGeneralInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LevelService_GetLevelGeneralInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LevelServiceServer).GetLevelGeneralInfo(ctx, req.(*GetLevelGeneralInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LevelService_GetLevelGem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLevelGemRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LevelServiceServer).GetLevelGem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LevelService_GetLevelGem_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LevelServiceServer).GetLevelGem(ctx, req.(*GetLevelGemRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LevelService_GetLevelGift_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLevelGiftRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LevelServiceServer).GetLevelGift(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LevelService_GetLevelGift_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LevelServiceServer).GetLevelGift(ctx, req.(*GetLevelGiftRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LevelService_GetLevelLicenses_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLevelLicensesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LevelServiceServer).GetLevelLicenses(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LevelService_GetLevelLicenses_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LevelServiceServer).GetLevelLicenses(ctx, req.(*GetLevelLicensesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LevelService_GetLevelPrizes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLevelPrizesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LevelServiceServer).GetLevelPrizes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LevelService_GetLevelPrizes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LevelServiceServer).GetLevelPrizes(ctx, req.(*GetLevelPrizesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LevelService_ClaimPrize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClaimPrizeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LevelServiceServer).ClaimPrize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LevelService_ClaimPrize_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LevelServiceServer).ClaimPrize(ctx, req.(*ClaimPrizeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// LevelService_ServiceDesc is the grpc.ServiceDesc for LevelService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LevelService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "levels.LevelService",
	HandlerType: (*LevelServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetUserLevel",
			Handler:    _LevelService_GetUserLevel_Handler,
		},
		{
			MethodName: "GetAllLevels",
			Handler:    _LevelService_GetAllLevels_Handler,
		},
		{
			MethodName: "GetLevel",
			Handler:    _LevelService_GetLevel_Handler,
		},
		{
			MethodName: "GetLevelGeneralInfo",
			Handler:    _LevelService_GetLevelGeneralInfo_Handler,
		},
		{
			MethodName: "GetLevelGem",
			Handler:    _LevelService_GetLevelGem_Handler,
		},
		{
			MethodName: "GetLevelGift",
			Handler:    _LevelService_GetLevelGift_Handler,
		},
		{
			MethodName: "GetLevelLicenses",
			Handler:    _LevelService_GetLevelLicenses_Handler,
		},
		{
			MethodName: "GetLevelPrizes",
			Handler:    _LevelService_GetLevelPrizes_Handler,
		},
		{
			MethodName: "ClaimPrize",
			Handler:    _LevelService_ClaimPrize_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "levels.proto",
}

const (
	ActivityService_LogActivity_FullMethodName         = "/levels.ActivityService/LogActivity"
	ActivityService_GetUserActivities_FullMethodName   = "/levels.ActivityService/GetUserActivities"
	ActivityService_UpdateActivityScore_FullMethodName = "/levels.ActivityService/UpdateActivityScore"
	ActivityService_RecordTrade_FullMethodName         = "/levels.ActivityService/RecordTrade"
	ActivityService_RecordDeposit_FullMethodName       = "/levels.ActivityService/RecordDeposit"
	ActivityService_RecordFollower_FullMethodName      = "/levels.ActivityService/RecordFollower"
)

// ActivityServiceClient is the client API for ActivityService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ActivityService handles user activity tracking
type ActivityServiceClient interface {
	LogActivity(ctx context.Context, in *LogActivityRequest, opts ...grpc.CallOption) (*LogActivityResponse, error)
	GetUserActivities(ctx context.Context, in *GetUserActivitiesRequest, opts ...grpc.CallOption) (*UserActivitiesResponse, error)
	UpdateActivityScore(ctx context.Context, in *UpdateActivityScoreRequest, opts ...grpc.CallOption) (*UpdateActivityScoreResponse, error)
	RecordTrade(ctx context.Context, in *RecordTradeRequest, opts ...grpc.CallOption) (*RecordTradeResponse, error)
	RecordDeposit(ctx context.Context, in *RecordDepositRequest, opts ...grpc.CallOption) (*RecordDepositResponse, error)
	RecordFollower(ctx context.Context, in *RecordFollowerRequest, opts ...grpc.CallOption) (*RecordFollowerResponse, error)
}

type activityServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewActivityServiceClient(cc grpc.ClientConnInterface) ActivityServiceClient {
	return &activityServiceClient{cc}
}

func (c *activityServiceClient) LogActivity(ctx context.Context, in *LogActivityRequest, opts ...grpc.CallOption) (*LogActivityResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LogActivityResponse)
	err := c.cc.Invoke(ctx, ActivityService_LogActivity_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *activityServiceClient) GetUserActivities(ctx context.Context, in *GetUserActivitiesRequest, opts ...grpc.CallOption) (*UserActivitiesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserActivitiesResponse)
	err := c.cc.Invoke(ctx, ActivityService_GetUserActivities_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *activityServiceClient) UpdateActivityScore(ctx context.Context, in *UpdateActivityScoreRequest, opts ...grpc.CallOption) (*UpdateActivityScoreResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateActivityScoreResponse)
	err := c.cc.Invoke(ctx, ActivityService_UpdateActivityScore_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *activityServiceClient) RecordTrade(ctx context.Context, in *RecordTradeRequest, opts ...grpc.CallOption) (*RecordTradeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RecordTradeResponse)
	err := c.cc.Invoke(ctx, ActivityService_RecordTrade_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *activityServiceClient) RecordDeposit(ctx context.Context, in *RecordDepositRequest, opts ...grpc.CallOption) (*RecordDepositResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RecordDepositResponse)
	err := c.cc.Invoke(ctx, ActivityService_RecordDeposit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *activityServiceClient) RecordFollower(ctx context.Context, in *RecordFollowerRequest, opts ...grpc.CallOption) (*RecordFollowerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RecordFollowerResponse)
	err := c.cc.Invoke(ctx, ActivityService_RecordFollower_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ActivityServiceServer is the server API for ActivityService service.
// All implementations must embed UnimplementedActivityServiceServer
// for forward compatibility.
//
// ActivityService handles user activity tracking
type ActivityServiceServer interface {
	LogActivity(context.Context, *LogActivityRequest) (*LogActivityResponse, error)
	GetUserActivities(context.Context, *GetUserActivitiesRequest) (*UserActivitiesResponse, error)
	UpdateActivityScore(context.Context, *UpdateActivityScoreRequest) (*UpdateActivityScoreResponse, error)
	RecordTrade(context.Context, *RecordTradeRequest) (*RecordTradeResponse, error)
	RecordDeposit(context.Context, *RecordDepositRequest) (*RecordDepositResponse, error)
	RecordFollower(context.Context, *RecordFollowerRequest) (*RecordFollowerResponse, error)
	mustEmbedUnimplementedActivityServiceServer()
}

// UnimplementedActivityServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedActivityServiceServer struct{}

func (UnimplementedActivityServiceServer) LogActivity(context.Context, *LogActivityRequest) (*LogActivityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LogActivity not implemented")
}
func (UnimplementedActivityServiceServer) GetUserActivities(context.Context, *GetUserActivitiesRequest) (*UserActivitiesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserActivities not implemented")
}
func (UnimplementedActivityServiceServer) UpdateActivityScore(context.Context, *UpdateActivityScoreRequest) (*UpdateActivityScoreResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateActivityScore not implemented")
}
func (UnimplementedActivityServiceServer) RecordTrade(context.Context, *RecordTradeRequest) (*RecordTradeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RecordTrade not implemented")
}
func (UnimplementedActivityServiceServer) RecordDeposit(context.Context, *RecordDepositRequest) (*RecordDepositResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RecordDeposit not implemented")
}
func (UnimplementedActivityServiceServer) RecordFollower(context.Context, *RecordFollowerRequest) (*RecordFollowerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RecordFollower not implemented")
}
func (UnimplementedActivityServiceServer) mustEmbedUnimplementedActivityServiceServer() {}
func (UnimplementedActivityServiceServer) testEmbeddedByValue()                         {}

// UnsafeActivityServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ActivityServiceServer will
// result in compilation errors.
type UnsafeActivityServiceServer interface {
	mustEmbedUnimplementedActivityServiceServer()
}

func RegisterActivityServiceServer(s grpc.ServiceRegistrar, srv ActivityServiceServer) {
	// If the following call pancis, it indicates UnimplementedActivityServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ActivityService_ServiceDesc, srv)
}

func _ActivityService_LogActivity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogActivityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActivityServiceServer).LogActivity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ActivityService_LogActivity_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActivityServiceServer).LogActivity(ctx, req.(*LogActivityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ActivityService_GetUserActivities_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserActivitiesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActivityServiceServer).GetUserActivities(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ActivityService_GetUserActivities_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActivityServiceServer).GetUserActivities(ctx, req.(*GetUserActivitiesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ActivityService_UpdateActivityScore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateActivityScoreRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActivityServiceServer).UpdateActivityScore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ActivityService_UpdateActivityScore_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActivityServiceServer).UpdateActivityScore(ctx, req.(*UpdateActivityScoreRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ActivityService_RecordTrade_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecordTradeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActivityServiceServer).RecordTrade(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ActivityService_RecordTrade_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActivityServiceServer).RecordTrade(ctx, req.(*RecordTradeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ActivityService_RecordDeposit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecordDepositRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActivityServiceServer).RecordDeposit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ActivityService_RecordDeposit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActivityServiceServer).RecordDeposit(ctx, req.(*RecordDepositRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ActivityService_RecordFollower_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecordFollowerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActivityServiceServer).RecordFollower(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ActivityService_RecordFollower_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActivityServiceServer).RecordFollower(ctx, req.(*RecordFollowerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ActivityService_ServiceDesc is the grpc.ServiceDesc for ActivityService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ActivityService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "levels.ActivityService",
	HandlerType: (*ActivityServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "LogActivity",
			Handler:    _ActivityService_LogActivity_Handler,
		},
		{
			MethodName: "GetUserActivities",
			Handler:    _ActivityService_GetUserActivities_Handler,
		},
		{
			MethodName: "UpdateActivityScore",
			Handler:    _ActivityService_UpdateActivityScore_Handler,
		},
		{
			MethodName: "RecordTrade",
			Handler:    _ActivityService_RecordTrade_Handler,
		},
		{
			MethodName: "RecordDeposit",
			Handler:    _ActivityService_RecordDeposit_Handler,
		},
		{
			MethodName: "RecordFollower",
			Handler:    _ActivityService_RecordFollower_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "levels.proto",
}

const (
	ChallengeService_GetQuestion_FullMethodName  = "/levels.ChallengeService/GetQuestion"
	ChallengeService_SubmitAnswer_FullMethodName = "/levels.ChallengeService/SubmitAnswer"
	ChallengeService_GetTimings_FullMethodName   = "/levels.ChallengeService/GetTimings"
)

// ChallengeServiceClient is the client API for ChallengeService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ChallengeService handles quiz challenges
type ChallengeServiceClient interface {
	GetQuestion(ctx context.Context, in *GetQuestionRequest, opts ...grpc.CallOption) (*QuestionResponse, error)
	SubmitAnswer(ctx context.Context, in *SubmitAnswerRequest, opts ...grpc.CallOption) (*AnswerResultResponse, error)
	GetTimings(ctx context.Context, in *GetTimingsRequest, opts ...grpc.CallOption) (*TimingsResponse, error)
}

type challengeServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewChallengeServiceClient(cc grpc.ClientConnInterface) ChallengeServiceClient {
	return &challengeServiceClient{cc}
}

func (c *challengeServiceClient) GetQuestion(ctx context.Context, in *GetQuestionRequest, opts ...grpc.CallOption) (*QuestionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QuestionResponse)
	err := c.cc.Invoke(ctx, ChallengeService_GetQuestion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *challengeServiceClient) SubmitAnswer(ctx context.Context, in *SubmitAnswerRequest, opts ...grpc.CallOption) (*AnswerResultResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AnswerResultResponse)
	err := c.cc.Invoke(ctx, ChallengeService_SubmitAnswer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *challengeServiceClient) GetTimings(ctx context.Context, in *GetTimingsRequest, opts ...grpc.CallOption) (*TimingsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TimingsResponse)
	err := c.cc.Invoke(ctx, ChallengeService_GetTimings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ChallengeServiceServer is the server API for ChallengeService service.
// All implementations must embed UnimplementedChallengeServiceServer
// for forward compatibility.
//
// ChallengeService handles quiz challenges
type ChallengeServiceServer interface {
	GetQuestion(context.Context, *GetQuestionRequest) (*QuestionResponse, error)
	SubmitAnswer(context.Context, *SubmitAnswerRequest) (*AnswerResultResponse, error)
	GetTimings(context.Context, *GetTimingsRequest) (*TimingsResponse, error)
	mustEmbedUnimplementedChallengeServiceServer()
}

// UnimplementedChallengeServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedChallengeServiceServer struct{}

func (UnimplementedChallengeServiceServer) GetQuestion(context.Context, *GetQuestionRequest) (*QuestionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetQuestion not implemented")
}
func (UnimplementedChallengeServiceServer) SubmitAnswer(context.Context, *SubmitAnswerRequest) (*AnswerResultResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitAnswer not implemented")
}
func (UnimplementedChallengeServiceServer) GetTimings(context.Context, *GetTimingsRequest) (*TimingsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTimings not implemented")
}
func (UnimplementedChallengeServiceServer) mustEmbedUnimplementedChallengeServiceServer() {}
func (UnimplementedChallengeServiceServer) testEmbeddedByValue()                          {}

// UnsafeChallengeServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ChallengeServiceServer will
// result in compilation errors.
type UnsafeChallengeServiceServer interface {
	mustEmbedUnimplementedChallengeServiceServer()
}

func RegisterChallengeServiceServer(s grpc.ServiceRegistrar, srv ChallengeServiceServer) {
	// If the following call pancis, it indicates UnimplementedChallengeServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ChallengeService_ServiceDesc, srv)
}

func _ChallengeService_GetQuestion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetQuestionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChallengeServiceServer).GetQuestion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChallengeService_GetQuestion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChallengeServiceServer).GetQuestion(ctx, req.(*GetQuestionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChallengeService_SubmitAnswer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitAnswerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChallengeServiceServer).SubmitAnswer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChallengeService_SubmitAnswer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChallengeServiceServer).SubmitAnswer(ctx, req.(*SubmitAnswerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChallengeService_GetTimings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTimingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChallengeServiceServer).GetTimings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChallengeService_GetTimings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChallengeServiceServer).GetTimings(ctx, req.(*GetTimingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ChallengeService_ServiceDesc is the grpc.ServiceDesc for ChallengeService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ChallengeService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "levels.ChallengeService",
	HandlerType: (*ChallengeServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetQuestion",
			Handler:    _ChallengeService_GetQuestion_Handler,
		},
		{
			MethodName: "SubmitAnswer",
			Handler:    _ChallengeService_SubmitAnswer_Handler,
		},
		{
			MethodName: "GetTimings",
			Handler:    _ChallengeService_GetTimings_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "levels.proto",
}
