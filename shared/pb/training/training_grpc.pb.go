// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v5.29.3
// source: training.proto

package training

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	common "metargb/shared/pb/common"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	VideoService_GetVideos_FullMethodName          = "/training.VideoService/GetVideos"
	VideoService_GetVideo_FullMethodName           = "/training.VideoService/GetVideo"
	VideoService_GetVideoByFileName_FullMethodName = "/training.VideoService/GetVideoByFileName"
	VideoService_SearchVideos_FullMethodName       = "/training.VideoService/SearchVideos"
	VideoService_IncrementView_FullMethodName      = "/training.VideoService/IncrementView"
	VideoService_AddInteraction_FullMethodName     = "/training.VideoService/AddInteraction"
)

// VideoServiceClient is the client API for VideoService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// VideoService handles video tutorials
type VideoServiceClient interface {
	GetVideos(ctx context.Context, in *GetVideosRequest, opts ...grpc.CallOption) (*VideosResponse, error)
	GetVideo(ctx context.Context, in *GetVideoRequest, opts ...grpc.CallOption) (*VideoResponse, error)
	GetVideoByFileName(ctx context.Context, in *GetVideoByFileNameRequest, opts ...grpc.CallOption) (*VideoResponse, error)
	SearchVideos(ctx context.Context, in *SearchVideosRequest, opts ...grpc.CallOption) (*VideosResponse, error)
	IncrementView(ctx context.Context, in *IncrementViewRequest, opts ...grpc.CallOption) (*common.Empty, error)
	AddInteraction(ctx context.Context, in *AddInteractionRequest, opts ...grpc.CallOption) (*common.Empty, error)
}

type videoServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewVideoServiceClient(cc grpc.ClientConnInterface) VideoServiceClient {
	return &videoServiceClient{cc}
}

func (c *videoServiceClient) GetVideos(ctx context.Context, in *GetVideosRequest, opts ...grpc.CallOption) (*VideosResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VideosResponse)
	err := c.cc.Invoke(ctx, VideoService_GetVideos_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *videoServiceClient) GetVideo(ctx context.Context, in *GetVideoRequest, opts ...grpc.CallOption) (*VideoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VideoResponse)
	err := c.cc.Invoke(ctx, VideoService_GetVideo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *videoServiceClient) GetVideoByFileName(ctx context.Context, in *GetVideoByFileNameRequest, opts ...grpc.CallOption) (*VideoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VideoResponse)
	err := c.cc.Invoke(ctx, VideoService_GetVideoByFileName_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *videoServiceClient) SearchVideos(ctx context.Context, in *SearchVideosRequest, opts ...grpc.CallOption) (*VideosResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VideosResponse)
	err := c.cc.Invoke(ctx, VideoService_SearchVideos_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *videoServiceClient) IncrementView(ctx context.Context, in *IncrementViewRequest, opts ...grpc.CallOption) (*common.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, VideoService_IncrementView_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *videoServiceClient) AddInteraction(ctx context.Context, in *AddInteractionRequest, opts ...grpc.CallOption) (*common.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, VideoService_AddInteraction_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VideoServiceServer is the server API for VideoService service.
// All implementations must embed UnimplementedVideoServiceServer
// for forward compatibility.
//
// VideoService handles video tutorials
type VideoServiceServer interface {
	GetVideos(context.Context, *GetVideosRequest) (*VideosResponse, error)
	GetVideo(context.Context, *GetVideoRequest) (*VideoResponse, error)
	GetVideoByFileName(context.Context, *GetVideoByFileNameRequest) (*VideoResponse, error)
	SearchVideos(context.Context, *SearchVideosRequest) (*VideosResponse, error)
	IncrementView(context.Context, *IncrementViewRequest) (*common.Empty, error)
	AddInteraction(context.Context, *AddInteractionRequest) (*common.Empty, error)
	mustEmbedUnimplementedVideoServiceServer()
}

// UnimplementedVideoServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedVideoServiceServer struct{}

func (UnimplementedVideoServiceServer) GetVideos(context.Context, *GetVideosRequest) (*VideosResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetVideos not implemented")
}
func (UnimplementedVideoServiceServer) GetVideo(context.Context, *GetVideoRequest) (*VideoResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetVideo not implemented")
}
func (UnimplementedVideoServiceServer) GetVideoByFileName(context.Context, *GetVideoByFileNameRequest) (*VideoResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetVideoByFileName not implemented")
}
func (UnimplementedVideoServiceServer) SearchVideos(context.Context, *SearchVideosRequest) (*VideosResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SearchVideos not implemented")
}
func (UnimplementedVideoServiceServer) IncrementView(context.Context, *IncrementViewRequest) (*common.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method IncrementView not implemented")
}
func (UnimplementedVideoServiceServer) AddInteraction(context.Context, *AddInteractionRequest) (*common.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method AddInteraction not implemented")
}
func (UnimplementedVideoServiceServer) mustEmbedUnimplementedVideoServiceServer() {}
func (UnimplementedVideoServiceServer) testEmbeddedByValue()                      {}

// UnsafeVideoServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VideoServiceServer will
// result in compilation errors.
type UnsafeVideoServiceServer interface {
	mustEmbedUnimplementedVideoServiceServer()
}

func RegisterVideoServiceServer(s grpc.ServiceRegistrar, srv VideoServiceServer) {
	// If the following call panics, it indicates UnimplementedVideoServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&VideoService_ServiceDesc, srv)
}

func _VideoService_GetVideos_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVideosRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoServiceServer).GetVideos(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VideoService_GetVideos_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoServiceServer).GetVideos(ctx, req.(*GetVideosRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VideoService_GetVideo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVideoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoServiceServer).GetVideo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VideoService_GetVideo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoServiceServer).GetVideo(ctx, req.(*GetVideoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VideoService_GetVideoByFileName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVideoByFileNameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoServiceServer).GetVideoByFileName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VideoService_GetVideoByFileName_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoServiceServer).GetVideoByFileName(ctx, req.(*GetVideoByFileNameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VideoService_SearchVideos_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchVideosRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoServiceServer).SearchVideos(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VideoService_SearchVideos_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoServiceServer).SearchVideos(ctx, req.(*SearchVideosRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VideoService_IncrementView_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IncrementViewRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoServiceServer).IncrementView(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VideoService_IncrementView_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoServiceServer).IncrementView(ctx, req.(*IncrementViewRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VideoService_AddInteraction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddInteractionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoServiceServer).AddInteraction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VideoService_AddInteraction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoServiceServer).AddInteraction(ctx, req.(*AddInteractionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// VideoService_ServiceDesc is the grpc.ServiceDesc for VideoService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var VideoService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "training.VideoService",
	HandlerType: (*VideoServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetVideos",
			Handler:    _VideoService_GetVideos_Handler,
		},
		{
			MethodName: "GetVideo",
			Handler:    _VideoService_GetVideo_Handler,
		},
		{
			MethodName: "GetVideoByFileName",
			Handler:    _VideoService_GetVideoByFileName_Handler,
		},
		{
			MethodName: "SearchVideos",
			Handler:    _VideoService_SearchVideos_Handler,
		},
		{
			MethodName: "IncrementView",
			Handler:    _VideoService_IncrementView_Handler,
		},
		{
			MethodName: "AddInteraction",
			Handler:    _VideoService_AddInteraction_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "training.proto",
}

const (
	CategoryService_GetCategories_FullMethodName     = "/training.CategoryService/GetCategories"
	CategoryService_GetCategory_FullMethodName       = "/training.CategoryService/GetCategory"
	CategoryService_GetSubCategory_FullMethodName    = "/training.CategoryService/GetSubCategory"
	CategoryService_GetCategoryVideos_FullMethodName = "/training.CategoryService/GetCategoryVideos"
)

// CategoryServiceClient is the client API for CategoryService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// CategoryService handles video categories
type CategoryServiceClient interface {
	GetCategories(ctx context.Context, in *GetCategoriesRequest, opts ...grpc.CallOption) (*CategoriesResponse, error)
	GetCategory(ctx context.Context, in *GetCategoryRequest, opts ...grpc.CallOption) (*CategoryResponse, error)
	GetSubCategory(ctx context.Context, in *GetSubCategoryRequest, opts ...grpc.CallOption) (*SubCategoryResponse, error)
	GetCategoryVideos(ctx context.Context, in *GetCategoryVideosRequest, opts ...grpc.CallOption) (*VideosResponse, error)
}

type categoryServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCategoryServiceClient(cc grpc.ClientConnInterface) CategoryServiceClient {
	return &categoryServiceClient{cc}
}

func (c *categoryServiceClient) GetCategories(ctx context.Context, in *GetCategoriesRequest, opts ...grpc.CallOption) (*CategoriesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CategoriesResponse)
	err := c.cc.Invoke(ctx, CategoryService_GetCategories_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *categoryServiceClient) GetCategory(ctx context.Context, in *GetCategoryRequest, opts ...grpc.CallOption) (*CategoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CategoryResponse)
	err := c.cc.Invoke(ctx, CategoryService_GetCategory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *categoryServiceClient) GetSubCategory(ctx context.Context, in *GetSubCategoryRequest, opts ...grpc.CallOption) (*SubCategoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SubCategoryResponse)
	err := c.cc.Invoke(ctx, CategoryService_GetSubCategory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *categoryServiceClient) GetCategoryVideos(ctx context.Context, in *GetCategoryVideosRequest, opts ...grpc.CallOption) (*VideosResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VideosResponse)
	err := c.cc.Invoke(ctx, CategoryService_GetCategoryVideos_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CategoryServiceServer is the server API for CategoryService service.
// All implementations must embed UnimplementedCategoryServiceServer
// for forward compatibility.
//
// CategoryService handles video categories
type CategoryServiceServer interface {
	GetCategories(context.Context, *GetCategoriesRequest) (*CategoriesResponse, error)
	GetCategory(context.Context, *GetCategoryRequest) (*CategoryResponse, error)
	GetSubCategory(context.Context, *GetSubCategoryRequest) (*SubCategoryResponse, error)
	GetCategoryVideos(context.Context, *GetCategoryVideosRequest) (*VideosResponse, error)
	mustEmbedUnimplementedCategoryServiceServer()
}

// UnimplementedCategoryServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCategoryServiceServer struct{}

func (UnimplementedCategoryServiceServer) GetCategories(context.Context, *GetCategoriesRequest) (*CategoriesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetCategories not implemented")
}
func (UnimplementedCategoryServiceServer) GetCategory(context.Context, *GetCategoryRequest) (*CategoryResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetCategory not implemented")
}
func (UnimplementedCategoryServiceServer) GetSubCategory(context.Context, *GetSubCategoryRequest) (*SubCategoryResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSubCategory not implemented")
}
func (UnimplementedCategoryServiceServer) GetCategoryVideos(context.Context, *GetCategoryVideosRequest) (*VideosResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetCategoryVideos not implemented")
}
func (UnimplementedCategoryServiceServer) mustEmbedUnimplementedCategoryServiceServer() {}
func (UnimplementedCategoryServiceServer) testEmbeddedByValue()                         {}

// UnsafeCategoryServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CategoryServiceServer will
// result in compilation errors.
type UnsafeCategoryServiceServer interface {
	mustEmbedUnimplementedCategoryServiceServer()
}

func RegisterCategoryServiceServer(s grpc.ServiceRegistrar, srv CategoryServiceServer) {
	// If the following call panics, it indicates UnimplementedCategoryServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CategoryService_ServiceDesc, srv)
}

func _CategoryService_GetCategories_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCategoriesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CategoryServiceServer).GetCategories(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CategoryService_GetCategories_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CategoryServiceServer).GetCategories(ctx, req.(*GetCategoriesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CategoryService_GetCategory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCategoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CategoryServiceServer).GetCategory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CategoryService_GetCategory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CategoryServiceServer).GetCategory(ctx, req.(*GetCategoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CategoryService_GetSubCategory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSubCategoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CategoryServiceServer).GetSubCategory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CategoryService_GetSubCategory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CategoryServiceServer).GetSubCategory(ctx, req.(*GetSubCategoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CategoryService_GetCategoryVideos_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCategoryVideosRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CategoryServiceServer).GetCategoryVideos(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CategoryService_GetCategoryVideos_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CategoryServiceServer).GetCategoryVideos(ctx, req.(*GetCategoryVideosRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CategoryService_ServiceDesc is the grpc.ServiceDesc for CategoryService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CategoryService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "training.CategoryService",
	HandlerType: (*CategoryServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetCategories",
			Handler:    _CategoryService_GetCategories_Handler,
		},
		{
			MethodName: "GetCategory",
			Handler:    _CategoryService_GetCategory_Handler,
		},
		{
			MethodName: "GetSubCategory",
			Handler:    _CategoryService_GetSubCategory_Handler,
		},
		{
			MethodName: "GetCategoryVideos",
			Handler:    _CategoryService_GetCategoryVideos_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "training.proto",
}

const (
	CommentService_GetComments_FullMethodName           = "/training.CommentService/GetComments"
	CommentService_AddComment_FullMethodName            = "/training.CommentService/AddComment"
	CommentService_UpdateComment_FullMethodName         = "/training.CommentService/UpdateComment"
	CommentService_DeleteComment_FullMethodName         = "/training.CommentService/DeleteComment"
	CommentService_AddCommentInteraction_FullMethodName = "/training.CommentService/AddCommentInteraction"
	CommentService_ReportComment_FullMethodName         = "/training.CommentService/ReportComment"
)

// CommentServiceClient is the client API for CommentService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// CommentService handles video comments
type CommentServiceClient interface {
	GetComments(ctx context.Context, in *GetCommentsRequest, opts ...grpc.CallOption) (*CommentsResponse, error)
	AddComment(ctx context.Context, in *AddCommentRequest, opts ...grpc.CallOption) (*CommentResponse, error)
	UpdateComment(ctx context.Context, in *UpdateCommentRequest, opts ...grpc.CallOption) (*CommentResponse, error)
	DeleteComment(ctx context.Context, in *DeleteCommentRequest, opts ...grpc.CallOption) (*common.Empty, error)
	AddCommentInteraction(ctx context.Context, in *AddCommentInteractionRequest, opts ...grpc.CallOption) (*common.Empty, error)
	ReportComment(ctx context.Context, in *ReportCommentRequest, opts ...grpc.CallOption) (*common.Empty, error)
}

type commentServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCommentServiceClient(cc grpc.ClientConnInterface) CommentServiceClient {
	return &commentServiceClient{cc}
}

func (c *commentServiceClient) GetComments(ctx context.Context, in *GetCommentsRequest, opts ...grpc.CallOption) (*CommentsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CommentsResponse)
	err := c.cc.Invoke(ctx, CommentService_GetComments_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commentServiceClient) AddComment(ctx context.Context, in *AddCommentRequest, opts ...grpc.CallOption) (*CommentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CommentResponse)
	err := c.cc.Invoke(ctx, CommentService_AddComment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commentServiceClient) UpdateComment(ctx context.Context, in *UpdateCommentRequest, opts ...grpc.CallOption) (*CommentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CommentResponse)
	err := c.cc.Invoke(ctx, CommentService_UpdateComment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commentServiceClient) DeleteComment(ctx context.Context, in *DeleteCommentRequest, opts ...grpc.CallOption) (*common.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, CommentService_DeleteComment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commentServiceClient) AddCommentInteraction(ctx context.Context, in *AddCommentInteractionRequest, opts ...grpc.CallOption) (*common.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, CommentService_AddCommentInteraction_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commentServiceClient) ReportComment(ctx context.Context, in *ReportCommentRequest, opts ...grpc.CallOption) (*common.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, CommentService_ReportComment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CommentServiceServer is the server API for CommentService service.
// All implementations must embed UnimplementedCommentServiceServer
// for forward compatibility.
//
// CommentService handles video comments
type CommentServiceServer interface {
	GetComments(context.Context, *GetCommentsRequest) (*CommentsResponse, error)
	AddComment(context.Context, *AddCommentRequest) (*CommentResponse, error)
	UpdateComment(context.Context, *UpdateCommentRequest) (*CommentResponse, error)
	DeleteComment(context.Context, *DeleteCommentRequest) (*common.Empty, error)
	AddCommentInteraction(context.Context, *AddCommentInteractionRequest) (*common.Empty, error)
	ReportComment(context.Context, *ReportCommentRequest) (*common.Empty, error)
	mustEmbedUnimplementedCommentServiceServer()
}

// UnimplementedCommentServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCommentServiceServer struct{}

func (UnimplementedCommentServiceServer) GetComments(context.Context, *GetCommentsRequest) (*CommentsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetComments not implemented")
}
func (UnimplementedCommentServiceServer) AddComment(context.Context, *AddCommentRequest) (*CommentResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method AddComment not implemented")
}
func (UnimplementedCommentServiceServer) UpdateComment(context.Context, *UpdateCommentRequest) (*CommentResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateComment not implemented")
}
func (UnimplementedCommentServiceServer) DeleteComment(context.Context, *DeleteCommentRequest) (*common.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteComment not implemented")
}
func (UnimplementedCommentServiceServer) AddCommentInteraction(context.Context, *AddCommentInteractionRequest) (*common.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method AddCommentInteraction not implemented")
}
func (UnimplementedCommentServiceServer) ReportComment(context.Context, *ReportCommentRequest) (*common.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method ReportComment not implemented")
}
func (UnimplementedCommentServiceServer) mustEmbedUnimplementedCommentServiceServer() {}
func (UnimplementedCommentServiceServer) testEmbeddedByValue()                        {}

// UnsafeCommentServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CommentServiceServer will
// result in compilation errors.
type UnsafeCommentServiceServer interface {
	mustEmbedUnimplementedCommentServiceServer()
}

func RegisterCommentServiceServer(s grpc.ServiceRegistrar, srv CommentServiceServer) {
	// If the following call panics, it indicates UnimplementedCommentServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CommentService_ServiceDesc, srv)
}

func _CommentService_GetComments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCommentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommentServiceServer).GetComments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommentService_GetComments_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommentServiceServer).GetComments(ctx, req.(*GetCommentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommentService_AddComment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddCommentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommentServiceServer).AddComment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommentService_AddComment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommentServiceServer).AddComment(ctx, req.(*AddCommentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommentService_UpdateComment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateCommentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommentServiceServer).UpdateComment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommentService_UpdateComment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommentServiceServer).UpdateComment(ctx, req.(*UpdateCommentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommentService_DeleteComment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteCommentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommentServiceServer).DeleteComment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommentService_DeleteComment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommentServiceServer).DeleteComment(ctx, req.(*DeleteCommentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommentService_AddCommentInteraction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddCommentInteractionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommentServiceServer).AddCommentInteraction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommentService_AddCommentInteraction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommentServiceServer).AddCommentInteraction(ctx, req.(*AddCommentInteractionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommentService_ReportComment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportCommentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommentServiceServer).ReportComment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommentService_ReportComment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommentServiceServer).ReportComment(ctx, req.(*ReportCommentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CommentService_ServiceDesc is the grpc.ServiceDesc for CommentService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CommentService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "training.CommentService",
	HandlerType: (*CommentServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetComments",
			Handler:    _CommentService_GetComments_Handler,
		},
		{
			MethodName: "AddComment",
			Handler:    _CommentService_AddComment_Handler,
		},
		{
			MethodName: "UpdateComment",
			Handler:    _CommentService_UpdateComment_Handler,
		},
		{
			MethodName: "DeleteComment",
			Handler:    _CommentService_DeleteComment_Handler,
		},
		{
			MethodName: "AddCommentInteraction",
			Handler:    _CommentService_AddCommentInteraction_Handler,
		},
		{
			MethodName: "ReportComment",
			Handler:    _CommentService_ReportComment_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "training.proto",
}

const (
	ReplyService_GetReplies_FullMethodName          = "/training.ReplyService/GetReplies"
	ReplyService_AddReply_FullMethodName            = "/training.ReplyService/AddReply"
	ReplyService_UpdateReply_FullMethodName         = "/training.ReplyService/UpdateReply"
	ReplyService_DeleteReply_FullMethodName         = "/training.ReplyService/DeleteReply"
	ReplyService_AddReplyInteraction_FullMethodName = "/training.ReplyService/AddReplyInteraction"
)

// ReplyServiceClient is the client API for ReplyService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ReplyService handles comment replies
type ReplyServiceClient interface {
	GetReplies(ctx context.Context, in *GetRepliesRequest, opts ...grpc.CallOption) (*RepliesResponse, error)
	AddReply(ctx context.Context, in *AddReplyRequest, opts ...grpc.CallOption) (*CommentResponse, error)
	UpdateReply(ctx context.Context, in *UpdateReplyRequest, opts ...grpc.CallOption) (*CommentResponse, error)
	DeleteReply(ctx context.Context, in *DeleteReplyRequest, opts ...grpc.CallOption) (*common.Empty, error)
	AddReplyInteraction(ctx context.Context, in *AddReplyInteractionRequest, opts ...grpc.CallOption) (*common.Empty, error)
}

type replyServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewReplyServiceClient(cc grpc.ClientConnInterface) ReplyServiceClient {
	return &replyServiceClient{cc}
}

func (c *replyServiceClient) GetReplies(ctx context.Context, in *GetRepliesRequest, opts ...grpc.CallOption) (*RepliesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RepliesResponse)
	err := c.cc.Invoke(ctx, ReplyService_GetReplies_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *replyServiceClient) AddReply(ctx context.Context, in *AddReplyRequest, opts ...grpc.CallOption) (*CommentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CommentResponse)
	err := c.cc.Invoke(ctx, ReplyService_AddReply_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *replyServiceClient) UpdateReply(ctx context.Context, in *UpdateReplyRequest, opts ...grpc.CallOption) (*CommentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CommentResponse)
	err := c.cc.Invoke(ctx, ReplyService_UpdateReply_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *replyServiceClient) DeleteReply(ctx context.Context, in *DeleteReplyRequest, opts ...grpc.CallOption) (*common.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, ReplyService_DeleteReply_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *replyServiceClient) AddReplyInteraction(ctx context.Context, in *AddReplyInteractionRequest, opts ...grpc.CallOption) (*common.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(common.Empty)
	err := c.cc.Invoke(ctx, ReplyService_AddReplyInteraction_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ReplyServiceServer is the server API for ReplyService service.
// All implementations must embed UnimplementedReplyServiceServer
// for forward compatibility.
//
// ReplyService handles comment replies
type ReplyServiceServer interface {
	GetReplies(context.Context, *GetRepliesRequest) (*RepliesResponse, error)
	AddReply(context.Context, *AddReplyRequest) (*CommentResponse, error)
	UpdateReply(context.Context, *UpdateReplyRequest) (*CommentResponse, error)
	DeleteReply(context.Context, *DeleteReplyRequest) (*common.Empty, error)
	AddReplyInteraction(context.Context, *AddReplyInteractionRequest) (*common.Empty, error)
	mustEmbedUnimplementedReplyServiceServer()
}

// UnimplementedReplyServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedReplyServiceServer struct{}

func (UnimplementedReplyServiceServer) GetReplies(context.Context, *GetRepliesRequest) (*RepliesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetReplies not implemented")
}
func (UnimplementedReplyServiceServer) AddReply(context.Context, *AddReplyRequest) (*CommentResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method AddReply not implemented")
}
func (UnimplementedReplyServiceServer) UpdateReply(context.Context, *UpdateReplyRequest) (*CommentResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateReply not implemented")
}
func (UnimplementedReplyServiceServer) DeleteReply(context.Context, *DeleteReplyRequest) (*common.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteReply not implemented")
}
func (UnimplementedReplyServiceServer) AddReplyInteraction(context.Context, *AddReplyInteractionRequest) (*common.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method AddReplyInteraction not implemented")
}
func (UnimplementedReplyServiceServer) mustEmbedUnimplementedReplyServiceServer() {}
func (UnimplementedReplyServiceServer) testEmbeddedByValue()                      {}

// UnsafeReplyServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ReplyServiceServer will
// result in compilation errors.
type UnsafeReplyServiceServer interface {
	mustEmbedUnimplementedReplyServiceServer()
}

func RegisterReplyServiceServer(s grpc.ServiceRegistrar, srv ReplyServiceServer) {
	// If the following call panics, it indicates UnimplementedReplyServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ReplyService_ServiceDesc, srv)
}

func _ReplyService_GetReplies_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRepliesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReplyServiceServer).GetReplies(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReplyService_GetReplies_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReplyServiceServer).GetReplies(ctx, req.(*GetRepliesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReplyService_AddReply_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddReplyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReplyServiceServer).AddReply(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReplyService_AddReply_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReplyServiceServer).AddReply(ctx, req.(*AddReplyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReplyService_UpdateReply_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateReplyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReplyServiceServer).UpdateReply(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReplyService_UpdateReply_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReplyServiceServer).UpdateReply(ctx, req.(*UpdateReplyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReplyService_DeleteReply_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteReplyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReplyServiceServer).DeleteReply(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReplyService_DeleteReply_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReplyServiceServer).DeleteReply(ctx, req.(*DeleteReplyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReplyService_AddReplyInteraction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddReplyInteractionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReplyServiceServer).AddReplyInteraction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReplyService_AddReplyInteraction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReplyServiceServer).AddReplyInteraction(ctx, req.(*AddReplyInteractionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ReplyService_ServiceDesc is the grpc.ServiceDesc for ReplyService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ReplyService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "training.ReplyService",
	HandlerType: (*ReplyServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetReplies",
			Handler:    _ReplyService_GetReplies_Handler,
		},
		{
			MethodName: "AddReply",
			Handler:    _ReplyService_AddReply_Handler,
		},
		{
			MethodName: "UpdateReply",
			Handler:    _ReplyService_UpdateReply_Handler,
		},
		{
			MethodName: "DeleteReply",
			Handler:    _ReplyService_DeleteReply_Handler,
		},
		{
			MethodName: "AddReplyInteraction",
			Handler:    _ReplyService_AddReplyInteraction_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "training.proto",
}
