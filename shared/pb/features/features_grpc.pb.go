// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.3
// source: features.proto

package features

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	FeatureService_ListFeatures_FullMethodName     = "/features.FeatureService/ListFeatures"
	FeatureService_GetFeature_FullMethodName       = "/features.FeatureService/GetFeature"
	FeatureService_UpdateFeature_FullMethodName    = "/features.FeatureService/UpdateFeature"
	FeatureService_AddFeatureImages_FullMethodName = "/features.FeatureService/AddFeatureImages"
	FeatureService_GetMyFeatures_FullMethodName    = "/features.FeatureService/GetMyFeatures"
)

// FeatureServiceClient is the client API for FeatureService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// FeatureService handles feature CRUD operations
type FeatureServiceClient interface {
	ListFeatures(ctx context.Context, in *ListFeaturesRequest, opts ...grpc.CallOption) (*FeaturesResponse, error)
	GetFeature(ctx context.Context, in *GetFeatureRequest, opts ...grpc.CallOption) (*FeatureResponse, error)
	UpdateFeature(ctx context.Context, in *UpdateFeatureRequest, opts ...grpc.CallOption) (*FeatureResponse, error)
	AddFeatureImages(ctx context.Context, in *AddFeatureImagesRequest, opts ...grpc.CallOption) (*FeatureResponse, error)
	GetMyFeatures(ctx context.Context, in *GetMyFeaturesRequest, opts ...grpc.CallOption) (*FeaturesResponse, error)
}

type featureServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewFeatureServiceClient(cc grpc.ClientConnInterface) FeatureServiceClient {
	return &featureServiceClient{cc}
}

func (c *featureServiceClient) ListFeatures(ctx context.Context, in *ListFeaturesRequest, opts ...grpc.CallOption) (*FeaturesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FeaturesResponse)
	err := c.cc.Invoke(ctx, FeatureService_ListFeatures_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *featureServiceClient) GetFeature(ctx context.Context, in *GetFeatureRequest, opts ...grpc.CallOption) (*FeatureResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FeatureResponse)
	err := c.cc.Invoke(ctx, FeatureService_GetFeature_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *featureServiceClient) UpdateFeature(ctx context.Context, in *UpdateFeatureRequest, opts ...grpc.CallOption) (*FeatureResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FeatureResponse)
	err := c.cc.Invoke(ctx, FeatureService_UpdateFeature_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *featureServiceClient) AddFeatureImages(ctx context.Context, in *AddFeatureImagesRequest, opts ...grpc.CallOption) (*FeatureResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FeatureResponse)
	err := c.cc.Invoke(ctx, FeatureService_AddFeatureImages_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *featureServiceClient) GetMyFeatures(ctx context.Context, in *GetMyFeaturesRequest, opts ...grpc.CallOption) (*FeaturesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FeaturesResponse)
	err := c.cc.Invoke(ctx, FeatureService_GetMyFeatures_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FeatureServiceServer is the server API for FeatureService service.
// All implementations must embed UnimplementedFeatureServiceServer
// for forward compatibility.
//
// FeatureService handles feature CRUD operations
type FeatureServiceServer interface {
	ListFeatures(context.Context, *ListFeaturesRequest) (*FeaturesResponse, error)
	GetFeature(context.Context, *GetFeatureRequest) (*FeatureResponse, error)
	UpdateFeature(context.Context, *UpdateFeatureRequest) (*FeatureResponse, error)
	AddFeatureImages(context.Context, *AddFeatureImagesRequest) (*FeatureResponse, error)
	GetMyFeatures(context.Context, *GetMyFeaturesRequest) (*FeaturesResponse, error)
	mustEmbedUnimplementedFeatureServiceServer()
}

// UnimplementedFeatureServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedFeatureServiceServer struct{}

func (UnimplementedFeatureServiceServer) ListFeatures(context.Context, *ListFeaturesRequest) (*FeaturesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListFeatures not implemented")
}
func (UnimplementedFeatureServiceServer) GetFeature(context.Context, *GetFeatureRequest) (*FeatureResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFeature not implemented")
}
func (UnimplementedFeatureServiceServer) UpdateFeature(context.Context, *UpdateFeatureRequest) (*FeatureResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateFeature not implemented")
}
func (UnimplementedFeatureServiceServer) AddFeatureImages(context.Context, *AddFeatureImagesRequest) (*FeatureResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddFeatureImages not implemented")
}
func (UnimplementedFeatureServiceServer) GetMyFeatures(context.Context, *GetMyFeaturesRequest) (*FeaturesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMyFeatures not implemented")
}
func (UnimplementedFeatureServiceServer) mustEmbedUnimplementedFeatureServiceServer() {}
func (UnimplementedFeatureServiceServer) testEmbeddedByValue()                        {}

// UnsafeFeatureServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FeatureServiceServer will
// result in compilation errors.
type UnsafeFeatureServiceServer interface {
	mustEmbedUnimplementedFeatureServiceServer()
}

func RegisterFeatureServiceServer(s grpc.ServiceRegistrar, srv FeatureServiceServer) {
	// If the following call pancis, it indicates UnimplementedFeatureServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&FeatureService_ServiceDesc, srv)
}

func _FeatureService_ListFeatures_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListFeaturesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FeatureServiceServer).ListFeatures(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FeatureService_ListFeatures_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FeatureServiceServer).ListFeatures(ctx, req.(*ListFeaturesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FeatureService_GetFeature_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetFeatureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FeatureServiceServer).GetFeature(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FeatureService_GetFeature_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FeatureServiceServer).GetFeature(ctx, req.(*GetFeatureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FeatureService_UpdateFeature_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateFeatureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FeatureServiceServer).UpdateFeature(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FeatureService_UpdateFeature_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FeatureServiceServer).UpdateFeature(ctx, req.(*UpdateFeatureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FeatureService_AddFeatureImages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddFeatureImagesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FeatureServiceServer).AddFeatureImages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FeatureService_AddFeatureImages_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FeatureServiceServer).AddFeatureImages(ctx, req.(*AddFeatureImagesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FeatureService_GetMyFeatures_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMyFeaturesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FeatureServiceServer).GetMyFeatures(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FeatureService_GetMyFeatures_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FeatureServiceServer).GetMyFeatures(ctx, req.(*GetMyFeaturesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// FeatureService_ServiceDesc is the grpc.ServiceDesc for FeatureService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FeatureService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "features.FeatureService",
	HandlerType: (*FeatureServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListFeatures",
			Handler:    _FeatureService_ListFeatures_Handler,
		},
		{
			MethodName: "GetFeature",
			Handler:    _FeatureService_GetFeature_Handler,
		},
		{
			MethodName: "UpdateFeature",
			Handler:    _FeatureService_UpdateFeature_Handler,
		},
		{
			MethodName: "AddFeatureImages",
			Handler:    _FeatureService_AddFeatureImages_Handler,
		},
		{
			MethodName: "GetMyFeatures",
			Handler:    _FeatureService_GetMyFeatures_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "features.proto",
}

const (
	FeatureMarketplaceService_BuyFeature_FullMethodName         = "/features.FeatureMarketplaceService/BuyFeature"
	FeatureMarketplaceService_SendBuyRequest_FullMethodName     = "/features.FeatureMarketplaceService/SendBuyRequest"
	FeatureMarketplaceService_AcceptBuyRequest_FullMethodName   = "/features.FeatureMarketplaceService/AcceptBuyRequest"
	FeatureMarketplaceService_CreateSellRequest_FullMethodName  = "/features.FeatureMarketplaceService/CreateSellRequest"
	FeatureMarketplaceService_RequestGracePeriod_FullMethodName = "/features.FeatureMarketplaceService/RequestGracePeriod"
)

// FeatureMarketplaceServiceClient is the client API for FeatureMarketplaceService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// FeatureMarketplaceService handles buying/selling features
type FeatureMarketplaceServiceClient interface {
	BuyFeature(ctx context.Context, in *BuyFeatureRequest, opts ...grpc.CallOption) (*BuyFeatureResponse, error)
	SendBuyRequest(ctx context.Context, in *SendBuyRequestRequest, opts ...grpc.CallOption) (*BuyRequestResponse, error)
	AcceptBuyRequest(ctx context.Context, in *AcceptBuyRequestRequest, opts ...grpc.CallOption) (*BuyRequestResponse, error)
	CreateSellRequest(ctx context.Context, in *CreateSellRequestRequest, opts ...grpc.CallOption) (*SellRequestResponse, error)
	RequestGracePeriod(ctx context.Context, in *RequestGracePeriodRequest, opts ...grpc.CallOption) (*GracePeriodResponse, error)
}

type featureMarketplaceServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewFeatureMarketplaceServiceClient(cc grpc.ClientConnInterface) FeatureMarketplaceServiceClient {
	return &featureMarketplaceServiceClient{cc}
}

func (c *featureMarketplaceServiceClient) BuyFeature(ctx context.Context, in *BuyFeatureRequest, opts ...grpc.CallOption) (*BuyFeatureResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BuyFeatureResponse)
	err := c.cc.Invoke(ctx, FeatureMarketplaceService_BuyFeature_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *featureMarketplaceServiceClient) SendBuyRequest(ctx context.Context, in *SendBuyRequestRequest, opts ...grpc.CallOption) (*BuyRequestResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BuyRequestResponse)
	err := c.cc.Invoke(ctx, FeatureMarketplaceService_SendBuyRequest_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *featureMarketplaceServiceClient) AcceptBuyRequest(ctx context.Context, in *AcceptBuyRequestRequest, opts ...grpc.CallOption) (*BuyRequestResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BuyRequestResponse)
	err := c.cc.Invoke(ctx, FeatureMarketplaceService_AcceptBuyRequest_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *featureMarketplaceServiceClient) CreateSellRequest(ctx context.Context, in *CreateSellRequestRequest, opts ...grpc.CallOption) (*SellRequestResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SellRequestResponse)
	err := c.cc.Invoke(ctx, FeatureMarketplaceService_CreateSellRequest_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *featureMarketplaceServiceClient) RequestGracePeriod(ctx context.Context, in *RequestGracePeriodRequest, opts ...grpc.CallOption) (*GracePeriodResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GracePeriodResponse)
	err := c.cc.Invoke(ctx, FeatureMarketplaceService_RequestGracePeriod_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FeatureMarketplaceServiceServer is the server API for FeatureMarketplaceService service.
// All implementations must embed UnimplementedFeatureMarketplaceServiceServer
// for forward compatibility.
//
// FeatureMarketplaceService handles buying/selling features
type FeatureMarketplaceServiceServer interface {
	BuyFeature(context.Context, *BuyFeatureRequest) (*BuyFeatureResponse, error)
	SendBuyRequest(context.Context, *SendBuyRequestRequest) (*BuyRequestResponse, error)
	AcceptBuyRequest(context.Context, *AcceptBuyRequestRequest) (*BuyRequestResponse, error)
	CreateSellRequest(context.Context, *CreateSellRequestRequest) (*SellRequestResponse, error)
	RequestGracePeriod(context.Context, *RequestGracePeriodRequest) (*GracePeriodResponse, error)
	mustEmbedUnimplementedFeatureMarketplaceServiceServer()
}

// UnimplementedFeatureMarketplaceServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedFeatureMarketplaceServiceServer struct{}

func (UnimplementedFeatureMarketplaceServiceServer) BuyFeature(context.Context, *BuyFeatureRequest) (*BuyFeatureResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BuyFeature not implemented")
}
func (UnimplementedFeatureMarketplaceServiceServer) SendBuyRequest(context.Context, *SendBuyRequestRequest) (*BuyRequestResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendBuyRequest not implemented")
}
func (UnimplementedFeatureMarketplaceServiceServer) AcceptBuyRequest(context.Context, *AcceptBuyRequestRequest) (*BuyRequestResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AcceptBuyRequest not implemented")
}
func (UnimplementedFeatureMarketplaceServiceServer) CreateSellRequest(context.Context, *CreateSellRequestRequest) (*SellRequestResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSellRequest not implemented")
}
func (UnimplementedFeatureMarketplaceServiceServer) RequestGracePeriod(context.Context, *RequestGracePeriodRequest) (*GracePeriodResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequestGracePeriod not implemented")
}
func (UnimplementedFeatureMarketplaceServiceServer) mustEmbedUnimplementedFeatureMarketplaceServiceServer() {
}
func (UnimplementedFeatureMarketplaceServiceServer) testEmbeddedByValue() {}

// UnsafeFeatureMarketplaceServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FeatureMarketplaceServiceServer will
// result in compilation errors.
type UnsafeFeatureMarketplaceServiceServer interface {
	mustEmbedUnimplementedFeatureMarketplaceServiceServer()
}

func RegisterFeatureMarketplaceServiceServer(s grpc.ServiceRegistrar, srv FeatureMarketplaceServiceServer) {
	// If the following call pancis, it indicates UnimplementedFeatureMarketplaceServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&FeatureMarketplaceService_ServiceDesc, srv)
}

func _FeatureMarketplaceService_BuyFeature_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BuyFeatureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FeatureMarketplaceServiceServer).BuyFeature(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FeatureMarketplaceService_BuyFeature_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FeatureMarketplaceServiceServer).BuyFeature(ctx, req.(*BuyFeatureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FeatureMarketplaceService_SendBuyRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendBuyRequestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FeatureMarketplaceServiceServer).SendBuyRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FeatureMarketplaceService_SendBuyRequest_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FeatureMarketplaceServiceServer).SendBuyRequest(ctx, req.(*SendBuyRequestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FeatureMarketplaceService_AcceptBuyRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AcceptBuyRequestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FeatureMarketplaceServiceServer).AcceptBuyRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FeatureMarketplaceService_AcceptBuyRequest_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FeatureMarketplaceServiceServer).AcceptBuyRequest(ctx, req.(*AcceptBuyRequestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FeatureMarketplaceService_CreateSellRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateSellRequestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FeatureMarketplaceServiceServer).CreateSellRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FeatureMarketplaceService_CreateSellRequest_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FeatureMarketplaceServiceServer).CreateSellRequest(ctx, req.(*CreateSellRequestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FeatureMarketplaceService_RequestGracePeriod_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestGracePeriodRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FeatureMarketplaceServiceServer).RequestGracePeriod(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FeatureMarketplaceService_RequestGracePeriod_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FeatureMarketplaceServiceServer).RequestGracePeriod(ctx, req.(*RequestGracePeriodRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// FeatureMarketplaceService_ServiceDesc is the grpc.ServiceDesc for FeatureMarketplaceService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FeatureMarketplaceService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "features.FeatureMarketplaceService",
	HandlerType: (*FeatureMarketplaceServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "BuyFeature",
			Handler:    _FeatureMarketplaceService_BuyFeature_Handler,
		},
		{
			MethodName: "SendBuyRequest",
			Handler:    _FeatureMarketplaceService_SendBuyRequest_Handler,
		},
		{
			MethodName: "AcceptBuyRequest",
			Handler:    _FeatureMarketplaceService_AcceptBuyRequest_Handler,
		},
		{
			MethodName: "CreateSellRequest",
			Handler:    _FeatureMarketplaceService_CreateSellRequest_Handler,
		},
		{
			MethodName: "RequestGracePeriod",
			Handler:    _FeatureMarketplaceService_RequestGracePeriod_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "features.proto",
}

const (
	FeatureProfitService_GetHourlyProfits_FullMethodName        = "/features.FeatureProfitService/GetHourlyProfits"
	FeatureProfitService_GetSingleProfit_FullMethodName         = "/features.FeatureProfitService/GetSingleProfit"
	FeatureProfitService_GetProfitsByApplication_FullMethodName = "/features.FeatureProfitService/GetProfitsByApplication"
)

// FeatureProfitServiceClient is the client API for FeatureProfitService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// FeatureProfitService handles hourly profit calculations
type FeatureProfitServiceClient interface {
	GetHourlyProfits(ctx context.Context, in *GetHourlyProfitsRequest, opts ...grpc.CallOption) (*HourlyProfitsResponse, error)
	GetSingleProfit(ctx context.Context, in *GetSingleProfitRequest, opts ...grpc.CallOption) (*HourlyProfitResponse, error)
	GetProfitsByApplication(ctx context.Context, in *GetProfitsByApplicationRequest, opts ...grpc.CallOption) (*ProfitsByApplicationResponse, error)
}

type featureProfitServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewFeatureProfitServiceClient(cc grpc.ClientConnInterface) FeatureProfitServiceClient {
	return &featureProfitServiceClient{cc}
}

func (c *featureProfitServiceClient) GetHourlyProfits(ctx context.Context, in *GetHourlyProfitsRequest, opts ...grpc.CallOption) (*HourlyProfitsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HourlyProfitsResponse)
	err := c.cc.Invoke(ctx, FeatureProfitService_GetHourlyProfits_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *featureProfitServiceClient) GetSingleProfit(ctx context.Context, in *GetSingleProfitRequest, opts ...grpc.CallOption) (*HourlyProfitResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HourlyProfitResponse)
	err := c.cc.Invoke(ctx, FeatureProfitService_GetSingleProfit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *featureProfitServiceClient) GetProfitsByApplication(ctx context.Context, in *GetProfitsByApplicationRequest, opts ...grpc.CallOption) (*ProfitsByApplicationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProfitsByApplicationResponse)
	err := c.cc.Invoke(ctx, FeatureProfitService_GetProfitsByApplication_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FeatureProfitServiceServer is the server API for FeatureProfitService service.
// All implementations must embed UnimplementedFeatureProfitServiceServer
// for forward compatibility.
//
// FeatureProfitService handles hourly profit calculations
type FeatureProfitServiceServer interface {
	GetHourlyProfits(context.Context, *GetHourlyProfitsRequest) (*HourlyProfitsResponse, error)
	GetSingleProfit(context.Context, *GetSingleProfitRequest) (*HourlyProfitResponse, error)
	GetProfitsByApplication(context.Context, *GetProfitsByApplicationRequest) (*ProfitsByApplicationResponse, error)
	mustEmbedUnimplementedFeatureProfitServiceServer()
}

// UnimplementedFeatureProfitServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedFeatureProfitServiceServer struct{}

func (UnimplementedFeatureProfitServiceServer) GetHourlyProfits(context.Context, *GetHourlyProfitsRequest) (*HourlyProfitsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHourlyProfits not implemented")
}
func (UnimplementedFeatureProfitServiceServer) GetSingleProfit(context.Context, *GetSingleProfitRequest) (*HourlyProfitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSingleProfit not implemented")
}
func (UnimplementedFeatureProfitServiceServer) GetProfitsByApplication(context.Context, *GetProfitsByApplicationRequest) (*ProfitsByApplicationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProfitsByApplication not implemented")
}
func (UnimplementedFeatureProfitServiceServer) mustEmbedUnimplementedFeatureProfitServiceServer() {}
func (UnimplementedFeatureProfitServiceServer) testEmbeddedByValue()                              {}

// UnsafeFeatureProfitServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FeatureProfitServiceServer will
// result in compilation errors.
type UnsafeFeatureProfitServiceServer interface {
	mustEmbedUnimplementedFeatureProfitServiceServer()
}

func RegisterFeatureProfitServiceServer(s grpc.ServiceRegistrar, srv FeatureProfitServiceServer) {
	// If the following call pancis, it indicates UnimplementedFeatureProfitServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&FeatureProfitService_ServiceDesc, srv)
}

func _FeatureProfitService_GetHourlyProfits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetHourlyProfitsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FeatureProfitServiceServer).GetHourlyProfits(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FeatureProfitService_GetHourlyProfits_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FeatureProfitServiceServer).GetHourlyProfits(ctx, req.(*GetHourlyProfitsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FeatureProfitService_GetSingleProfit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSingleProfitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FeatureProfitServiceServer).GetSingleProfit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FeatureProfitService_GetSingleProfit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FeatureProfitServiceServer).GetSingleProfit(ctx, req.(*GetSingleProfitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FeatureProfitService_GetProfitsByApplication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProfitsByApplicationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FeatureProfitServiceServer).GetProfitsByApplication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FeatureProfitService_GetProfitsByApplication_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FeatureProfitServiceServer).GetProfitsByApplication(ctx, req.(*GetProfitsByApplicationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// FeatureProfitService_ServiceDesc is the grpc.ServiceDesc for FeatureProfitService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FeatureProfitService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "features.FeatureProfitService",
	HandlerType: (*FeatureProfitServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetHourlyProfits",
			Handler:    _FeatureProfitService_GetHourlyProfits_Handler,
		},
		{
			MethodName: "GetSingleProfit",
			Handler:    _FeatureProfitService_GetSingleProfit_Handler,
		},
		{
			MethodName: "GetProfitsByApplication",
			Handler:    _FeatureProfitService_GetProfitsByApplication_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "features.proto",
}

const (
	BuildingService_GetBuildPackage_FullMethodName = "/features.BuildingService/GetBuildPackage"
	BuildingService_BuildFeature_FullMethodName    = "/features.BuildingService/BuildFeature"
	BuildingService_GetBuildings_FullMethodName    = "/features.BuildingService/GetBuildings"
	BuildingService_UpdateBuilding_FullMethodName  = "/features.BuildingService/UpdateBuilding"
	BuildingService_DestroyBuilding_FullMethodName = "/features.BuildingService/DestroyBuilding"
)

// BuildingServiceClient is the client API for BuildingService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// BuildingService handles building construction
type BuildingServiceClient interface {
	GetBuildPackage(ctx context.Context, in *GetBuildPackageRequest, opts ...grpc.CallOption) (*BuildPackageResponse, error)
	BuildFeature(ctx context.Context, in *BuildFeatureRequest, opts ...grpc.CallOption) (*BuildFeatureResponse, error)
	GetBuildings(ctx context.Context, in *GetBuildingsRequest, opts ...grpc.CallOption) (*BuildingsResponse, error)
	UpdateBuilding(ctx context.Context, in *UpdateBuildingRequest, opts ...grpc.CallOption) (*BuildingResponse, error)
	DestroyBuilding(ctx context.Context, in *DestroyBuildingRequest, opts ...grpc.CallOption) (*BuildingResponse, error)
}

type buildingServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewBuildingServiceClient(cc grpc.ClientConnInterface) BuildingServiceClient {
	return &buildingServiceClient{cc}
}

func (c *buildingServiceClient) GetBuildPackage(ctx context.Context, in *GetBuildPackageRequest, opts ...grpc.CallOption) (*BuildPackageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BuildPackageResponse)
	err := c.cc.Invoke(ctx, BuildingService_GetBuildPackage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildingServiceClient) BuildFeature(ctx context.Context, in *BuildFeatureRequest, opts ...grpc.CallOption) (*BuildFeatureResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BuildFeatureResponse)
	err := c.cc.Invoke(ctx, BuildingService_BuildFeature_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildingServiceClient) GetBuildings(ctx context.Context, in *GetBuildingsRequest, opts ...grpc.CallOption) (*BuildingsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BuildingsResponse)
	err := c.cc.Invoke(ctx, BuildingService_GetBuildings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildingServiceClient) UpdateBuilding(ctx context.Context, in *UpdateBuildingRequest, opts ...grpc.CallOption) (*BuildingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BuildingResponse)
	err := c.cc.Invoke(ctx, BuildingService_UpdateBuilding_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildingServiceClient) DestroyBuilding(ctx context.Context, in *DestroyBuildingRequest, opts ...grpc.CallOption) (*BuildingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BuildingResponse)
	err := c.cc.Invoke(ctx, BuildingService_DestroyBuilding_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BuildingServiceServer is the server API for BuildingService service.
// All implementations must embed UnimplementedBuildingServiceServer
// for forward compatibility.
//
// BuildingService handles building construction
type BuildingServiceServer interface {
	GetBuildPackage(context.Context, *GetBuildPackageRequest) (*BuildPackageResponse, error)
	BuildFeature(context.Context, *BuildFeatureRequest) (*BuildFeatureResponse, error)
	GetBuildings(context.Context, *GetBuildingsRequest) (*BuildingsResponse, error)
	UpdateBuilding(context.Context, *UpdateBuildingRequest) (*BuildingResponse, error)
	DestroyBuilding(context.Context, *DestroyBuildingRequest) (*BuildingResponse, error)
	mustEmbedUnimplementedBuildingServiceServer()
}

// UnimplementedBuildingServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedBuildingServiceServer struct{}

func (UnimplementedBuildingServiceServer) GetBuildPackage(context.Context, *GetBuildPackageRequest) (*BuildPackageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBuildPackage not implemented")
}
func (UnimplementedBuildingServiceServer) BuildFeature(context.Context, *BuildFeatureRequest) (*BuildFeatureResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BuildFeature not implemented")
}
func (UnimplementedBuildingServiceServer) GetBuildings(context.Context, *GetBuildingsRequest) (*BuildingsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBuildings not implemented")
}
func (UnimplementedBuildingServiceServer) UpdateBuilding(context.Context, *UpdateBuildingRequest) (*BuildingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateBuilding not implemented")
}
func (UnimplementedBuildingServiceServer) DestroyBuilding(context.Context, *DestroyBuildingRequest) (*BuildingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DestroyBuilding not implemented")
}
func (UnimplementedBuildingServiceServer) mustEmbedUnimplementedBuildingServiceServer() {}
func (UnimplementedBuildingServiceServer) testEmbeddedByValue()                         {}

// UnsafeBuildingServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BuildingServiceServer will
// result in compilation errors.
type UnsafeBuildingServiceServer interface {
	mustEmbedUnimplementedBuildingServiceServer()
}

func RegisterBuildingServiceServer(s grpc.ServiceRegistrar, srv BuildingServiceServer) {
	// If the following call pancis, it indicates UnimplementedBuildingServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&BuildingService_ServiceDesc, srv)
}

func _BuildingService_GetBuildPackage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBuildPackageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuildingServiceServer).GetBuildPackage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BuildingService_GetBuildPackage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuildingServiceServer).GetBuildPackage(ctx, req.(*GetBuildPackageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BuildingService_BuildFeature_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BuildFeatureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuildingServiceServer).BuildFeature(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BuildingService_BuildFeature_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuildingServiceServer).BuildFeature(ctx, req.(*BuildFeatureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BuildingService_GetBuildings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBuildingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuildingServiceServer).GetBuildings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BuildingService_GetBuildings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuildingServiceServer).GetBuildings(ctx, req.(*GetBuildingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BuildingService_UpdateBuilding_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateBuildingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuildingServiceServer).UpdateBuilding(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BuildingService_UpdateBuilding_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuildingServiceServer).UpdateBuilding(ctx, req.(*UpdateBuildingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BuildingService_DestroyBuilding_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DestroyBuildingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuildingServiceServer).DestroyBuilding(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BuildingService_DestroyBuilding_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuildingServiceServer).DestroyBuilding(ctx, req.(*DestroyBuildingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// BuildingService_ServiceDesc is the grpc.ServiceDesc for BuildingService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BuildingService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "features.BuildingService",
	HandlerType: (*BuildingServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetBuildPackage",
			Handler:    _BuildingService_GetBuildPackage_Handler,
		},
		{
			MethodName: "BuildFeature",
			Handler:    _BuildingService_BuildFeature_Handler,
		},
		{
			MethodName: "GetBuildings",
			Handler:    _BuildingService_GetBuildings_Handler,
		},
		{
			MethodName: "UpdateBuilding",
			Handler:    _BuildingService_UpdateBuilding_Handler,
		},
		{
			MethodName: "DestroyBuilding",
			Handler:    _BuildingService_DestroyBuilding_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "features.proto",
}
