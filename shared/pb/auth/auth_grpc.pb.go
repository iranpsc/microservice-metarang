// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v6.31.1
// source: auth.proto

package auth

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	AuthService_Register_FullMethodName               = "/auth.AuthService/Register"
	AuthService_Redirect_FullMethodName               = "/auth.AuthService/Redirect"
	AuthService_Callback_FullMethodName               = "/auth.AuthService/Callback"
	AuthService_GetMe_FullMethodName                  = "/auth.AuthService/GetMe"
	AuthService_Logout_FullMethodName                 = "/auth.AuthService/Logout"
	AuthService_ValidateToken_FullMethodName          = "/auth.AuthService/ValidateToken"
	AuthService_RequestAccountSecurity_FullMethodName = "/auth.AuthService/RequestAccountSecurity"
	AuthService_VerifyAccountSecurity_FullMethodName  = "/auth.AuthService/VerifyAccountSecurity"
)

// AuthServiceClient is the client API for AuthService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Auth Service - handles authentication and authorization
type AuthServiceClient interface {
	Register(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*RegisterResponse, error)
	Redirect(ctx context.Context, in *RedirectRequest, opts ...grpc.CallOption) (*RedirectResponse, error)
	Callback(ctx context.Context, in *CallbackRequest, opts ...grpc.CallOption) (*CallbackResponse, error)
	GetMe(ctx context.Context, in *GetMeRequest, opts ...grpc.CallOption) (*UserResponse, error)
	Logout(ctx context.Context, in *LogoutRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ValidateToken(ctx context.Context, in *ValidateTokenRequest, opts ...grpc.CallOption) (*ValidateTokenResponse, error)
	RequestAccountSecurity(ctx context.Context, in *RequestAccountSecurityRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	VerifyAccountSecurity(ctx context.Context, in *VerifyAccountSecurityRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type authServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAuthServiceClient(cc grpc.ClientConnInterface) AuthServiceClient {
	return &authServiceClient{cc}
}

func (c *authServiceClient) Register(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*RegisterResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterResponse)
	err := c.cc.Invoke(ctx, AuthService_Register_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) Redirect(ctx context.Context, in *RedirectRequest, opts ...grpc.CallOption) (*RedirectResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RedirectResponse)
	err := c.cc.Invoke(ctx, AuthService_Redirect_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) Callback(ctx context.Context, in *CallbackRequest, opts ...grpc.CallOption) (*CallbackResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CallbackResponse)
	err := c.cc.Invoke(ctx, AuthService_Callback_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) GetMe(ctx context.Context, in *GetMeRequest, opts ...grpc.CallOption) (*UserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserResponse)
	err := c.cc.Invoke(ctx, AuthService_GetMe_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) Logout(ctx context.Context, in *LogoutRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, AuthService_Logout_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) ValidateToken(ctx context.Context, in *ValidateTokenRequest, opts ...grpc.CallOption) (*ValidateTokenResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ValidateTokenResponse)
	err := c.cc.Invoke(ctx, AuthService_ValidateToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) RequestAccountSecurity(ctx context.Context, in *RequestAccountSecurityRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, AuthService_RequestAccountSecurity_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) VerifyAccountSecurity(ctx context.Context, in *VerifyAccountSecurityRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, AuthService_VerifyAccountSecurity_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AuthServiceServer is the server API for AuthService service.
// All implementations must embed UnimplementedAuthServiceServer
// for forward compatibility.
//
// Auth Service - handles authentication and authorization
type AuthServiceServer interface {
	Register(context.Context, *RegisterRequest) (*RegisterResponse, error)
	Redirect(context.Context, *RedirectRequest) (*RedirectResponse, error)
	Callback(context.Context, *CallbackRequest) (*CallbackResponse, error)
	GetMe(context.Context, *GetMeRequest) (*UserResponse, error)
	Logout(context.Context, *LogoutRequest) (*emptypb.Empty, error)
	ValidateToken(context.Context, *ValidateTokenRequest) (*ValidateTokenResponse, error)
	RequestAccountSecurity(context.Context, *RequestAccountSecurityRequest) (*emptypb.Empty, error)
	VerifyAccountSecurity(context.Context, *VerifyAccountSecurityRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedAuthServiceServer()
}

// UnimplementedAuthServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAuthServiceServer struct{}

func (UnimplementedAuthServiceServer) Register(context.Context, *RegisterRequest) (*RegisterResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Register not implemented")
}
func (UnimplementedAuthServiceServer) Redirect(context.Context, *RedirectRequest) (*RedirectResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Redirect not implemented")
}
func (UnimplementedAuthServiceServer) Callback(context.Context, *CallbackRequest) (*CallbackResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Callback not implemented")
}
func (UnimplementedAuthServiceServer) GetMe(context.Context, *GetMeRequest) (*UserResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetMe not implemented")
}
func (UnimplementedAuthServiceServer) Logout(context.Context, *LogoutRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method Logout not implemented")
}
func (UnimplementedAuthServiceServer) ValidateToken(context.Context, *ValidateTokenRequest) (*ValidateTokenResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ValidateToken not implemented")
}
func (UnimplementedAuthServiceServer) RequestAccountSecurity(context.Context, *RequestAccountSecurityRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method RequestAccountSecurity not implemented")
}
func (UnimplementedAuthServiceServer) VerifyAccountSecurity(context.Context, *VerifyAccountSecurityRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method VerifyAccountSecurity not implemented")
}
func (UnimplementedAuthServiceServer) mustEmbedUnimplementedAuthServiceServer() {}
func (UnimplementedAuthServiceServer) testEmbeddedByValue()                     {}

// UnsafeAuthServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AuthServiceServer will
// result in compilation errors.
type UnsafeAuthServiceServer interface {
	mustEmbedUnimplementedAuthServiceServer()
}

func RegisterAuthServiceServer(s grpc.ServiceRegistrar, srv AuthServiceServer) {
	// If the following call panics, it indicates UnimplementedAuthServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AuthService_ServiceDesc, srv)
}

func _AuthService_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).Register(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthService_Register_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).Register(ctx, req.(*RegisterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_Redirect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RedirectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).Redirect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthService_Redirect_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).Redirect(ctx, req.(*RedirectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_Callback_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CallbackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).Callback(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthService_Callback_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).Callback(ctx, req.(*CallbackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_GetMe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).GetMe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthService_GetMe_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).GetMe(ctx, req.(*GetMeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_Logout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogoutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).Logout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthService_Logout_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).Logout(ctx, req.(*LogoutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_ValidateToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).ValidateToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthService_ValidateToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).ValidateToken(ctx, req.(*ValidateTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_RequestAccountSecurity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestAccountSecurityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).RequestAccountSecurity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthService_RequestAccountSecurity_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).RequestAccountSecurity(ctx, req.(*RequestAccountSecurityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_VerifyAccountSecurity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyAccountSecurityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).VerifyAccountSecurity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AuthService_VerifyAccountSecurity_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).VerifyAccountSecurity(ctx, req.(*VerifyAccountSecurityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AuthService_ServiceDesc is the grpc.ServiceDesc for AuthService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AuthService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "auth.AuthService",
	HandlerType: (*AuthServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Register",
			Handler:    _AuthService_Register_Handler,
		},
		{
			MethodName: "Redirect",
			Handler:    _AuthService_Redirect_Handler,
		},
		{
			MethodName: "Callback",
			Handler:    _AuthService_Callback_Handler,
		},
		{
			MethodName: "GetMe",
			Handler:    _AuthService_GetMe_Handler,
		},
		{
			MethodName: "Logout",
			Handler:    _AuthService_Logout_Handler,
		},
		{
			MethodName: "ValidateToken",
			Handler:    _AuthService_ValidateToken_Handler,
		},
		{
			MethodName: "RequestAccountSecurity",
			Handler:    _AuthService_RequestAccountSecurity_Handler,
		},
		{
			MethodName: "VerifyAccountSecurity",
			Handler:    _AuthService_VerifyAccountSecurity_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "auth.proto",
}

const (
	UserService_GetUser_FullMethodName               = "/auth.UserService/GetUser"
	UserService_UpdateProfile_FullMethodName         = "/auth.UserService/UpdateProfile"
	UserService_ListUsers_FullMethodName             = "/auth.UserService/ListUsers"
	UserService_GetUserLevels_FullMethodName         = "/auth.UserService/GetUserLevels"
	UserService_GetUserProfile_FullMethodName        = "/auth.UserService/GetUserProfile"
	UserService_GetUserWallet_FullMethodName         = "/auth.UserService/GetUserWallet"
	UserService_GetUserLevel_FullMethodName          = "/auth.UserService/GetUserLevel"
	UserService_GetProfileLimitations_FullMethodName = "/auth.UserService/GetProfileLimitations"
	UserService_GetUserFeaturesCount_FullMethodName  = "/auth.UserService/GetUserFeaturesCount"
)

// UserServiceClient is the client API for UserService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// User Service - handles user profile and settings
type UserServiceClient interface {
	GetUser(ctx context.Context, in *GetUserRequest, opts ...grpc.CallOption) (*User, error)
	UpdateProfile(ctx context.Context, in *UpdateProfileRequest, opts ...grpc.CallOption) (*User, error)
	ListUsers(ctx context.Context, in *ListUsersRequest, opts ...grpc.CallOption) (*ListUsersResponse, error)
	GetUserLevels(ctx context.Context, in *GetUserLevelsRequest, opts ...grpc.CallOption) (*GetUserLevelsResponse, error)
	GetUserProfile(ctx context.Context, in *GetUserProfileRequest, opts ...grpc.CallOption) (*GetUserProfileResponse, error)
	GetUserWallet(ctx context.Context, in *GetUserWalletRequest, opts ...grpc.CallOption) (*UserWalletResponse, error)
	GetUserLevel(ctx context.Context, in *GetUserLevelRequest, opts ...grpc.CallOption) (*UserLevelResponse, error)
	GetProfileLimitations(ctx context.Context, in *GetProfileLimitationsRequest, opts ...grpc.CallOption) (*GetProfileLimitationsResponse, error)
	GetUserFeaturesCount(ctx context.Context, in *GetUserFeaturesCountRequest, opts ...grpc.CallOption) (*GetUserFeaturesCountResponse, error)
}

type userServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserServiceClient(cc grpc.ClientConnInterface) UserServiceClient {
	return &userServiceClient{cc}
}

func (c *userServiceClient) GetUser(ctx context.Context, in *GetUserRequest, opts ...grpc.CallOption) (*User, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(User)
	err := c.cc.Invoke(ctx, UserService_GetUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) UpdateProfile(ctx context.Context, in *UpdateProfileRequest, opts ...grpc.CallOption) (*User, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(User)
	err := c.cc.Invoke(ctx, UserService_UpdateProfile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) ListUsers(ctx context.Context, in *ListUsersRequest, opts ...grpc.CallOption) (*ListUsersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListUsersResponse)
	err := c.cc.Invoke(ctx, UserService_ListUsers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) GetUserLevels(ctx context.Context, in *GetUserLevelsRequest, opts ...grpc.CallOption) (*GetUserLevelsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUserLevelsResponse)
	err := c.cc.Invoke(ctx, UserService_GetUserLevels_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) GetUserProfile(ctx context.Context, in *GetUserProfileRequest, opts ...grpc.CallOption) (*GetUserProfileResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUserProfileResponse)
	err := c.cc.Invoke(ctx, UserService_GetUserProfile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) GetUserWallet(ctx context.Context, in *GetUserWalletRequest, opts ...grpc.CallOption) (*UserWalletResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserWalletResponse)
	err := c.cc.Invoke(ctx, UserService_GetUserWallet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) GetUserLevel(ctx context.Context, in *GetUserLevelRequest, opts ...grpc.CallOption) (*UserLevelResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserLevelResponse)
	err := c.cc.Invoke(ctx, UserService_GetUserLevel_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) GetProfileLimitations(ctx context.Context, in *GetProfileLimitationsRequest, opts ...grpc.CallOption) (*GetProfileLimitationsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetProfileLimitationsResponse)
	err := c.cc.Invoke(ctx, UserService_GetProfileLimitations_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) GetUserFeaturesCount(ctx context.Context, in *GetUserFeaturesCountRequest, opts ...grpc.CallOption) (*GetUserFeaturesCountResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUserFeaturesCountResponse)
	err := c.cc.Invoke(ctx, UserService_GetUserFeaturesCount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserServiceServer is the server API for UserService service.
// All implementations must embed UnimplementedUserServiceServer
// for forward compatibility.
//
// User Service - handles user profile and settings
type UserServiceServer interface {
	GetUser(context.Context, *GetUserRequest) (*User, error)
	UpdateProfile(context.Context, *UpdateProfileRequest) (*User, error)
	ListUsers(context.Context, *ListUsersRequest) (*ListUsersResponse, error)
	GetUserLevels(context.Context, *GetUserLevelsRequest) (*GetUserLevelsResponse, error)
	GetUserProfile(context.Context, *GetUserProfileRequest) (*GetUserProfileResponse, error)
	GetUserWallet(context.Context, *GetUserWalletRequest) (*UserWalletResponse, error)
	GetUserLevel(context.Context, *GetUserLevelRequest) (*UserLevelResponse, error)
	GetProfileLimitations(context.Context, *GetProfileLimitationsRequest) (*GetProfileLimitationsResponse, error)
	GetUserFeaturesCount(context.Context, *GetUserFeaturesCountRequest) (*GetUserFeaturesCountResponse, error)
	mustEmbedUnimplementedUserServiceServer()
}

// UnimplementedUserServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserServiceServer struct{}

func (UnimplementedUserServiceServer) GetUser(context.Context, *GetUserRequest) (*User, error) {
	return nil, status.Error(codes.Unimplemented, "method GetUser not implemented")
}
func (UnimplementedUserServiceServer) UpdateProfile(context.Context, *UpdateProfileRequest) (*User, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateProfile not implemented")
}
func (UnimplementedUserServiceServer) ListUsers(context.Context, *ListUsersRequest) (*ListUsersResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListUsers not implemented")
}
func (UnimplementedUserServiceServer) GetUserLevels(context.Context, *GetUserLevelsRequest) (*GetUserLevelsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetUserLevels not implemented")
}
func (UnimplementedUserServiceServer) GetUserProfile(context.Context, *GetUserProfileRequest) (*GetUserProfileResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetUserProfile not implemented")
}
func (UnimplementedUserServiceServer) GetUserWallet(context.Context, *GetUserWalletRequest) (*UserWalletResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetUserWallet not implemented")
}
func (UnimplementedUserServiceServer) GetUserLevel(context.Context, *GetUserLevelRequest) (*UserLevelResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetUserLevel not implemented")
}
func (UnimplementedUserServiceServer) GetProfileLimitations(context.Context, *GetProfileLimitationsRequest) (*GetProfileLimitationsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetProfileLimitations not implemented")
}
func (UnimplementedUserServiceServer) GetUserFeaturesCount(context.Context, *GetUserFeaturesCountRequest) (*GetUserFeaturesCountResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetUserFeaturesCount not implemented")
}
func (UnimplementedUserServiceServer) mustEmbedUnimplementedUserServiceServer() {}
func (UnimplementedUserServiceServer) testEmbeddedByValue()                     {}

// UnsafeUserServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserServiceServer will
// result in compilation errors.
type UnsafeUserServiceServer interface {
	mustEmbedUnimplementedUserServiceServer()
}

func RegisterUserServiceServer(s grpc.ServiceRegistrar, srv UserServiceServer) {
	// If the following call panics, it indicates UnimplementedUserServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserService_ServiceDesc, srv)
}

func _UserService_GetUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_GetUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetUser(ctx, req.(*GetUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_UpdateProfile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateProfileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).UpdateProfile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_UpdateProfile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).UpdateProfile(ctx, req.(*UpdateProfileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_ListUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListUsersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).ListUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_ListUsers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).ListUsers(ctx, req.(*ListUsersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_GetUserLevels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserLevelsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetUserLevels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_GetUserLevels_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetUserLevels(ctx, req.(*GetUserLevelsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_GetUserProfile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserProfileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetUserProfile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_GetUserProfile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetUserProfile(ctx, req.(*GetUserProfileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_GetUserWallet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserWalletRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetUserWallet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_GetUserWallet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetUserWallet(ctx, req.(*GetUserWalletRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_GetUserLevel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserLevelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetUserLevel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_GetUserLevel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetUserLevel(ctx, req.(*GetUserLevelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_GetProfileLimitations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProfileLimitationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetProfileLimitations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_GetProfileLimitations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetProfileLimitations(ctx, req.(*GetProfileLimitationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_GetUserFeaturesCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserFeaturesCountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetUserFeaturesCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_GetUserFeaturesCount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetUserFeaturesCount(ctx, req.(*GetUserFeaturesCountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// UserService_ServiceDesc is the grpc.ServiceDesc for UserService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "auth.UserService",
	HandlerType: (*UserServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetUser",
			Handler:    _UserService_GetUser_Handler,
		},
		{
			MethodName: "UpdateProfile",
			Handler:    _UserService_UpdateProfile_Handler,
		},
		{
			MethodName: "ListUsers",
			Handler:    _UserService_ListUsers_Handler,
		},
		{
			MethodName: "GetUserLevels",
			Handler:    _UserService_GetUserLevels_Handler,
		},
		{
			MethodName: "GetUserProfile",
			Handler:    _UserService_GetUserProfile_Handler,
		},
		{
			MethodName: "GetUserWallet",
			Handler:    _UserService_GetUserWallet_Handler,
		},
		{
			MethodName: "GetUserLevel",
			Handler:    _UserService_GetUserLevel_Handler,
		},
		{
			MethodName: "GetProfileLimitations",
			Handler:    _UserService_GetProfileLimitations_Handler,
		},
		{
			MethodName: "GetUserFeaturesCount",
			Handler:    _UserService_GetUserFeaturesCount_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "auth.proto",
}

const (
	ProfileLimitationService_CreateProfileLimitation_FullMethodName = "/auth.ProfileLimitationService/CreateProfileLimitation"
	ProfileLimitationService_UpdateProfileLimitation_FullMethodName = "/auth.ProfileLimitationService/UpdateProfileLimitation"
	ProfileLimitationService_DeleteProfileLimitation_FullMethodName = "/auth.ProfileLimitationService/DeleteProfileLimitation"
	ProfileLimitationService_GetProfileLimitation_FullMethodName    = "/auth.ProfileLimitationService/GetProfileLimitation"
)

// ProfileLimitationServiceClient is the client API for ProfileLimitationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Profile Limitation Service - handles profile limitations between users
type ProfileLimitationServiceClient interface {
	CreateProfileLimitation(ctx context.Context, in *CreateProfileLimitationRequest, opts ...grpc.CallOption) (*ProfileLimitationResponse, error)
	UpdateProfileLimitation(ctx context.Context, in *UpdateProfileLimitationRequest, opts ...grpc.CallOption) (*ProfileLimitationResponse, error)
	DeleteProfileLimitation(ctx context.Context, in *DeleteProfileLimitationRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetProfileLimitation(ctx context.Context, in *GetProfileLimitationRequest, opts ...grpc.CallOption) (*ProfileLimitationResponse, error)
}

type profileLimitationServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewProfileLimitationServiceClient(cc grpc.ClientConnInterface) ProfileLimitationServiceClient {
	return &profileLimitationServiceClient{cc}
}

func (c *profileLimitationServiceClient) CreateProfileLimitation(ctx context.Context, in *CreateProfileLimitationRequest, opts ...grpc.CallOption) (*ProfileLimitationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProfileLimitationResponse)
	err := c.cc.Invoke(ctx, ProfileLimitationService_CreateProfileLimitation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *profileLimitationServiceClient) UpdateProfileLimitation(ctx context.Context, in *UpdateProfileLimitationRequest, opts ...grpc.CallOption) (*ProfileLimitationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProfileLimitationResponse)
	err := c.cc.Invoke(ctx, ProfileLimitationService_UpdateProfileLimitation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *profileLimitationServiceClient) DeleteProfileLimitation(ctx context.Context, in *DeleteProfileLimitationRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ProfileLimitationService_DeleteProfileLimitation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *profileLimitationServiceClient) GetProfileLimitation(ctx context.Context, in *GetProfileLimitationRequest, opts ...grpc.CallOption) (*ProfileLimitationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProfileLimitationResponse)
	err := c.cc.Invoke(ctx, ProfileLimitationService_GetProfileLimitation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProfileLimitationServiceServer is the server API for ProfileLimitationService service.
// All implementations must embed UnimplementedProfileLimitationServiceServer
// for forward compatibility.
//
// Profile Limitation Service - handles profile limitations between users
type ProfileLimitationServiceServer interface {
	CreateProfileLimitation(context.Context, *CreateProfileLimitationRequest) (*ProfileLimitationResponse, error)
	UpdateProfileLimitation(context.Context, *UpdateProfileLimitationRequest) (*ProfileLimitationResponse, error)
	DeleteProfileLimitation(context.Context, *DeleteProfileLimitationRequest) (*emptypb.Empty, error)
	GetProfileLimitation(context.Context, *GetProfileLimitationRequest) (*ProfileLimitationResponse, error)
	mustEmbedUnimplementedProfileLimitationServiceServer()
}

// UnimplementedProfileLimitationServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedProfileLimitationServiceServer struct{}

func (UnimplementedProfileLimitationServiceServer) CreateProfileLimitation(context.Context, *CreateProfileLimitationRequest) (*ProfileLimitationResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateProfileLimitation not implemented")
}
func (UnimplementedProfileLimitationServiceServer) UpdateProfileLimitation(context.Context, *UpdateProfileLimitationRequest) (*ProfileLimitationResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateProfileLimitation not implemented")
}
func (UnimplementedProfileLimitationServiceServer) DeleteProfileLimitation(context.Context, *DeleteProfileLimitationRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteProfileLimitation not implemented")
}
func (UnimplementedProfileLimitationServiceServer) GetProfileLimitation(context.Context, *GetProfileLimitationRequest) (*ProfileLimitationResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetProfileLimitation not implemented")
}
func (UnimplementedProfileLimitationServiceServer) mustEmbedUnimplementedProfileLimitationServiceServer() {
}
func (UnimplementedProfileLimitationServiceServer) testEmbeddedByValue() {}

// UnsafeProfileLimitationServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProfileLimitationServiceServer will
// result in compilation errors.
type UnsafeProfileLimitationServiceServer interface {
	mustEmbedUnimplementedProfileLimitationServiceServer()
}

func RegisterProfileLimitationServiceServer(s grpc.ServiceRegistrar, srv ProfileLimitationServiceServer) {
	// If the following call panics, it indicates UnimplementedProfileLimitationServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ProfileLimitationService_ServiceDesc, srv)
}

func _ProfileLimitationService_CreateProfileLimitation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateProfileLimitationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProfileLimitationServiceServer).CreateProfileLimitation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProfileLimitationService_CreateProfileLimitation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProfileLimitationServiceServer).CreateProfileLimitation(ctx, req.(*CreateProfileLimitationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProfileLimitationService_UpdateProfileLimitation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateProfileLimitationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProfileLimitationServiceServer).UpdateProfileLimitation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProfileLimitationService_UpdateProfileLimitation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProfileLimitationServiceServer).UpdateProfileLimitation(ctx, req.(*UpdateProfileLimitationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProfileLimitationService_DeleteProfileLimitation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteProfileLimitationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProfileLimitationServiceServer).DeleteProfileLimitation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProfileLimitationService_DeleteProfileLimitation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProfileLimitationServiceServer).DeleteProfileLimitation(ctx, req.(*DeleteProfileLimitationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProfileLimitationService_GetProfileLimitation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProfileLimitationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProfileLimitationServiceServer).GetProfileLimitation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProfileLimitationService_GetProfileLimitation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProfileLimitationServiceServer).GetProfileLimitation(ctx, req.(*GetProfileLimitationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ProfileLimitationService_ServiceDesc is the grpc.ServiceDesc for ProfileLimitationService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ProfileLimitationService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "auth.ProfileLimitationService",
	HandlerType: (*ProfileLimitationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateProfileLimitation",
			Handler:    _ProfileLimitationService_CreateProfileLimitation_Handler,
		},
		{
			MethodName: "UpdateProfileLimitation",
			Handler:    _ProfileLimitationService_UpdateProfileLimitation_Handler,
		},
		{
			MethodName: "DeleteProfileLimitation",
			Handler:    _ProfileLimitationService_DeleteProfileLimitation_Handler,
		},
		{
			MethodName: "GetProfileLimitation",
			Handler:    _ProfileLimitationService_GetProfileLimitation_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "auth.proto",
}

const (
	KYCService_GetKYC_FullMethodName            = "/auth.KYCService/GetKYC"
	KYCService_UpdateKYC_FullMethodName         = "/auth.KYCService/UpdateKYC"
	KYCService_ListBankAccounts_FullMethodName  = "/auth.KYCService/ListBankAccounts"
	KYCService_CreateBankAccount_FullMethodName = "/auth.KYCService/CreateBankAccount"
	KYCService_GetBankAccount_FullMethodName    = "/auth.KYCService/GetBankAccount"
	KYCService_UpdateBankAccount_FullMethodName = "/auth.KYCService/UpdateBankAccount"
	KYCService_DeleteBankAccount_FullMethodName = "/auth.KYCService/DeleteBankAccount"
)

// KYCServiceClient is the client API for KYCService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// KYC Service - handles KYC verification
type KYCServiceClient interface {
	GetKYC(ctx context.Context, in *GetKYCRequest, opts ...grpc.CallOption) (*KYCResponse, error)
	UpdateKYC(ctx context.Context, in *UpdateKYCRequest, opts ...grpc.CallOption) (*KYCResponse, error)
	ListBankAccounts(ctx context.Context, in *ListBankAccountsRequest, opts ...grpc.CallOption) (*ListBankAccountsResponse, error)
	CreateBankAccount(ctx context.Context, in *CreateBankAccountRequest, opts ...grpc.CallOption) (*BankAccountResponse, error)
	GetBankAccount(ctx context.Context, in *GetBankAccountRequest, opts ...grpc.CallOption) (*BankAccountResponse, error)
	UpdateBankAccount(ctx context.Context, in *UpdateBankAccountRequest, opts ...grpc.CallOption) (*BankAccountResponse, error)
	DeleteBankAccount(ctx context.Context, in *DeleteBankAccountRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type kYCServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewKYCServiceClient(cc grpc.ClientConnInterface) KYCServiceClient {
	return &kYCServiceClient{cc}
}

func (c *kYCServiceClient) GetKYC(ctx context.Context, in *GetKYCRequest, opts ...grpc.CallOption) (*KYCResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(KYCResponse)
	err := c.cc.Invoke(ctx, KYCService_GetKYC_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kYCServiceClient) UpdateKYC(ctx context.Context, in *UpdateKYCRequest, opts ...grpc.CallOption) (*KYCResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(KYCResponse)
	err := c.cc.Invoke(ctx, KYCService_UpdateKYC_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kYCServiceClient) ListBankAccounts(ctx context.Context, in *ListBankAccountsRequest, opts ...grpc.CallOption) (*ListBankAccountsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListBankAccountsResponse)
	err := c.cc.Invoke(ctx, KYCService_ListBankAccounts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kYCServiceClient) CreateBankAccount(ctx context.Context, in *CreateBankAccountRequest, opts ...grpc.CallOption) (*BankAccountResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BankAccountResponse)
	err := c.cc.Invoke(ctx, KYCService_CreateBankAccount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kYCServiceClient) GetBankAccount(ctx context.Context, in *GetBankAccountRequest, opts ...grpc.CallOption) (*BankAccountResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BankAccountResponse)
	err := c.cc.Invoke(ctx, KYCService_GetBankAccount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kYCServiceClient) UpdateBankAccount(ctx context.Context, in *UpdateBankAccountRequest, opts ...grpc.CallOption) (*BankAccountResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BankAccountResponse)
	err := c.cc.Invoke(ctx, KYCService_UpdateBankAccount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kYCServiceClient) DeleteBankAccount(ctx context.Context, in *DeleteBankAccountRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, KYCService_DeleteBankAccount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// KYCServiceServer is the server API for KYCService service.
// All implementations must embed UnimplementedKYCServiceServer
// for forward compatibility.
//
// KYC Service - handles KYC verification
type KYCServiceServer interface {
	GetKYC(context.Context, *GetKYCRequest) (*KYCResponse, error)
	UpdateKYC(context.Context, *UpdateKYCRequest) (*KYCResponse, error)
	ListBankAccounts(context.Context, *ListBankAccountsRequest) (*ListBankAccountsResponse, error)
	CreateBankAccount(context.Context, *CreateBankAccountRequest) (*BankAccountResponse, error)
	GetBankAccount(context.Context, *GetBankAccountRequest) (*BankAccountResponse, error)
	UpdateBankAccount(context.Context, *UpdateBankAccountRequest) (*BankAccountResponse, error)
	DeleteBankAccount(context.Context, *DeleteBankAccountRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedKYCServiceServer()
}

// UnimplementedKYCServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedKYCServiceServer struct{}

func (UnimplementedKYCServiceServer) GetKYC(context.Context, *GetKYCRequest) (*KYCResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetKYC not implemented")
}
func (UnimplementedKYCServiceServer) UpdateKYC(context.Context, *UpdateKYCRequest) (*KYCResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateKYC not implemented")
}
func (UnimplementedKYCServiceServer) ListBankAccounts(context.Context, *ListBankAccountsRequest) (*ListBankAccountsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListBankAccounts not implemented")
}
func (UnimplementedKYCServiceServer) CreateBankAccount(context.Context, *CreateBankAccountRequest) (*BankAccountResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateBankAccount not implemented")
}
func (UnimplementedKYCServiceServer) GetBankAccount(context.Context, *GetBankAccountRequest) (*BankAccountResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetBankAccount not implemented")
}
func (UnimplementedKYCServiceServer) UpdateBankAccount(context.Context, *UpdateBankAccountRequest) (*BankAccountResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateBankAccount not implemented")
}
func (UnimplementedKYCServiceServer) DeleteBankAccount(context.Context, *DeleteBankAccountRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteBankAccount not implemented")
}
func (UnimplementedKYCServiceServer) mustEmbedUnimplementedKYCServiceServer() {}
func (UnimplementedKYCServiceServer) testEmbeddedByValue()                    {}

// UnsafeKYCServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to KYCServiceServer will
// result in compilation errors.
type UnsafeKYCServiceServer interface {
	mustEmbedUnimplementedKYCServiceServer()
}

func RegisterKYCServiceServer(s grpc.ServiceRegistrar, srv KYCServiceServer) {
	// If the following call panics, it indicates UnimplementedKYCServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&KYCService_ServiceDesc, srv)
}

func _KYCService_GetKYC_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetKYCRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KYCServiceServer).GetKYC(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KYCService_GetKYC_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KYCServiceServer).GetKYC(ctx, req.(*GetKYCRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KYCService_UpdateKYC_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateKYCRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KYCServiceServer).UpdateKYC(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KYCService_UpdateKYC_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KYCServiceServer).UpdateKYC(ctx, req.(*UpdateKYCRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KYCService_ListBankAccounts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListBankAccountsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KYCServiceServer).ListBankAccounts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KYCService_ListBankAccounts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KYCServiceServer).ListBankAccounts(ctx, req.(*ListBankAccountsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KYCService_CreateBankAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateBankAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KYCServiceServer).CreateBankAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KYCService_CreateBankAccount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KYCServiceServer).CreateBankAccount(ctx, req.(*CreateBankAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KYCService_GetBankAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBankAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KYCServiceServer).GetBankAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KYCService_GetBankAccount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KYCServiceServer).GetBankAccount(ctx, req.(*GetBankAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KYCService_UpdateBankAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateBankAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KYCServiceServer).UpdateBankAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KYCService_UpdateBankAccount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KYCServiceServer).UpdateBankAccount(ctx, req.(*UpdateBankAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KYCService_DeleteBankAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteBankAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KYCServiceServer).DeleteBankAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: KYCService_DeleteBankAccount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KYCServiceServer).DeleteBankAccount(ctx, req.(*DeleteBankAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// KYCService_ServiceDesc is the grpc.ServiceDesc for KYCService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var KYCService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "auth.KYCService",
	HandlerType: (*KYCServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetKYC",
			Handler:    _KYCService_GetKYC_Handler,
		},
		{
			MethodName: "UpdateKYC",
			Handler:    _KYCService_UpdateKYC_Handler,
		},
		{
			MethodName: "ListBankAccounts",
			Handler:    _KYCService_ListBankAccounts_Handler,
		},
		{
			MethodName: "CreateBankAccount",
			Handler:    _KYCService_CreateBankAccount_Handler,
		},
		{
			MethodName: "GetBankAccount",
			Handler:    _KYCService_GetBankAccount_Handler,
		},
		{
			MethodName: "UpdateBankAccount",
			Handler:    _KYCService_UpdateBankAccount_Handler,
		},
		{
			MethodName: "DeleteBankAccount",
			Handler:    _KYCService_DeleteBankAccount_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "auth.proto",
}

const (
	CitizenService_GetCitizenProfile_FullMethodName       = "/auth.CitizenService/GetCitizenProfile"
	CitizenService_GetCitizenReferrals_FullMethodName     = "/auth.CitizenService/GetCitizenReferrals"
	CitizenService_GetCitizenReferralChart_FullMethodName = "/auth.CitizenService/GetCitizenReferralChart"
)

// CitizenServiceClient is the client API for CitizenService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Citizen Service - handles public citizen profile endpoints (no authentication required)
type CitizenServiceClient interface {
	GetCitizenProfile(ctx context.Context, in *GetCitizenProfileRequest, opts ...grpc.CallOption) (*CitizenProfileResponse, error)
	GetCitizenReferrals(ctx context.Context, in *GetCitizenReferralsRequest, opts ...grpc.CallOption) (*CitizenReferralsResponse, error)
	GetCitizenReferralChart(ctx context.Context, in *GetCitizenReferralChartRequest, opts ...grpc.CallOption) (*CitizenReferralChartResponse, error)
}

type citizenServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCitizenServiceClient(cc grpc.ClientConnInterface) CitizenServiceClient {
	return &citizenServiceClient{cc}
}

func (c *citizenServiceClient) GetCitizenProfile(ctx context.Context, in *GetCitizenProfileRequest, opts ...grpc.CallOption) (*CitizenProfileResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CitizenProfileResponse)
	err := c.cc.Invoke(ctx, CitizenService_GetCitizenProfile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *citizenServiceClient) GetCitizenReferrals(ctx context.Context, in *GetCitizenReferralsRequest, opts ...grpc.CallOption) (*CitizenReferralsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CitizenReferralsResponse)
	err := c.cc.Invoke(ctx, CitizenService_GetCitizenReferrals_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *citizenServiceClient) GetCitizenReferralChart(ctx context.Context, in *GetCitizenReferralChartRequest, opts ...grpc.CallOption) (*CitizenReferralChartResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CitizenReferralChartResponse)
	err := c.cc.Invoke(ctx, CitizenService_GetCitizenReferralChart_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CitizenServiceServer is the server API for CitizenService service.
// All implementations must embed UnimplementedCitizenServiceServer
// for forward compatibility.
//
// Citizen Service - handles public citizen profile endpoints (no authentication required)
type CitizenServiceServer interface {
	GetCitizenProfile(context.Context, *GetCitizenProfileRequest) (*CitizenProfileResponse, error)
	GetCitizenReferrals(context.Context, *GetCitizenReferralsRequest) (*CitizenReferralsResponse, error)
	GetCitizenReferralChart(context.Context, *GetCitizenReferralChartRequest) (*CitizenReferralChartResponse, error)
	mustEmbedUnimplementedCitizenServiceServer()
}

// UnimplementedCitizenServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCitizenServiceServer struct{}

func (UnimplementedCitizenServiceServer) GetCitizenProfile(context.Context, *GetCitizenProfileRequest) (*CitizenProfileResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetCitizenProfile not implemented")
}
func (UnimplementedCitizenServiceServer) GetCitizenReferrals(context.Context, *GetCitizenReferralsRequest) (*CitizenReferralsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetCitizenReferrals not implemented")
}
func (UnimplementedCitizenServiceServer) GetCitizenReferralChart(context.Context, *GetCitizenReferralChartRequest) (*CitizenReferralChartResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetCitizenReferralChart not implemented")
}
func (UnimplementedCitizenServiceServer) mustEmbedUnimplementedCitizenServiceServer() {}
func (UnimplementedCitizenServiceServer) testEmbeddedByValue()                        {}

// UnsafeCitizenServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CitizenServiceServer will
// result in compilation errors.
type UnsafeCitizenServiceServer interface {
	mustEmbedUnimplementedCitizenServiceServer()
}

func RegisterCitizenServiceServer(s grpc.ServiceRegistrar, srv CitizenServiceServer) {
	// If the following call panics, it indicates UnimplementedCitizenServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CitizenService_ServiceDesc, srv)
}

func _CitizenService_GetCitizenProfile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCitizenProfileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CitizenServiceServer).GetCitizenProfile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CitizenService_GetCitizenProfile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CitizenServiceServer).GetCitizenProfile(ctx, req.(*GetCitizenProfileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CitizenService_GetCitizenReferrals_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCitizenReferralsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CitizenServiceServer).GetCitizenReferrals(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CitizenService_GetCitizenReferrals_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CitizenServiceServer).GetCitizenReferrals(ctx, req.(*GetCitizenReferralsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CitizenService_GetCitizenReferralChart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCitizenReferralChartRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CitizenServiceServer).GetCitizenReferralChart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CitizenService_GetCitizenReferralChart_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CitizenServiceServer).GetCitizenReferralChart(ctx, req.(*GetCitizenReferralChartRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CitizenService_ServiceDesc is the grpc.ServiceDesc for CitizenService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CitizenService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "auth.CitizenService",
	HandlerType: (*CitizenServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetCitizenProfile",
			Handler:    _CitizenService_GetCitizenProfile_Handler,
		},
		{
			MethodName: "GetCitizenReferrals",
			Handler:    _CitizenService_GetCitizenReferrals_Handler,
		},
		{
			MethodName: "GetCitizenReferralChart",
			Handler:    _CitizenService_GetCitizenReferralChart_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "auth.proto",
}

const (
	PersonalInfoService_GetPersonalInfo_FullMethodName    = "/auth.PersonalInfoService/GetPersonalInfo"
	PersonalInfoService_UpdatePersonalInfo_FullMethodName = "/auth.PersonalInfoService/UpdatePersonalInfo"
)

// PersonalInfoServiceClient is the client API for PersonalInfoService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// PersonalInfo Service - handles personal information endpoints
type PersonalInfoServiceClient interface {
	GetPersonalInfo(ctx context.Context, in *GetPersonalInfoRequest, opts ...grpc.CallOption) (*GetPersonalInfoResponse, error)
	UpdatePersonalInfo(ctx context.Context, in *UpdatePersonalInfoRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type personalInfoServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPersonalInfoServiceClient(cc grpc.ClientConnInterface) PersonalInfoServiceClient {
	return &personalInfoServiceClient{cc}
}

func (c *personalInfoServiceClient) GetPersonalInfo(ctx context.Context, in *GetPersonalInfoRequest, opts ...grpc.CallOption) (*GetPersonalInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetPersonalInfoResponse)
	err := c.cc.Invoke(ctx, PersonalInfoService_GetPersonalInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *personalInfoServiceClient) UpdatePersonalInfo(ctx context.Context, in *UpdatePersonalInfoRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, PersonalInfoService_UpdatePersonalInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PersonalInfoServiceServer is the server API for PersonalInfoService service.
// All implementations must embed UnimplementedPersonalInfoServiceServer
// for forward compatibility.
//
// PersonalInfo Service - handles personal information endpoints
type PersonalInfoServiceServer interface {
	GetPersonalInfo(context.Context, *GetPersonalInfoRequest) (*GetPersonalInfoResponse, error)
	UpdatePersonalInfo(context.Context, *UpdatePersonalInfoRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedPersonalInfoServiceServer()
}

// UnimplementedPersonalInfoServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedPersonalInfoServiceServer struct{}

func (UnimplementedPersonalInfoServiceServer) GetPersonalInfo(context.Context, *GetPersonalInfoRequest) (*GetPersonalInfoResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetPersonalInfo not implemented")
}
func (UnimplementedPersonalInfoServiceServer) UpdatePersonalInfo(context.Context, *UpdatePersonalInfoRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdatePersonalInfo not implemented")
}
func (UnimplementedPersonalInfoServiceServer) mustEmbedUnimplementedPersonalInfoServiceServer() {}
func (UnimplementedPersonalInfoServiceServer) testEmbeddedByValue()                             {}

// UnsafePersonalInfoServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PersonalInfoServiceServer will
// result in compilation errors.
type UnsafePersonalInfoServiceServer interface {
	mustEmbedUnimplementedPersonalInfoServiceServer()
}

func RegisterPersonalInfoServiceServer(s grpc.ServiceRegistrar, srv PersonalInfoServiceServer) {
	// If the following call panics, it indicates UnimplementedPersonalInfoServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&PersonalInfoService_ServiceDesc, srv)
}

func _PersonalInfoService_GetPersonalInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPersonalInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PersonalInfoServiceServer).GetPersonalInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PersonalInfoService_GetPersonalInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PersonalInfoServiceServer).GetPersonalInfo(ctx, req.(*GetPersonalInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PersonalInfoService_UpdatePersonalInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatePersonalInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PersonalInfoServiceServer).UpdatePersonalInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PersonalInfoService_UpdatePersonalInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PersonalInfoServiceServer).UpdatePersonalInfo(ctx, req.(*UpdatePersonalInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PersonalInfoService_ServiceDesc is the grpc.ServiceDesc for PersonalInfoService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PersonalInfoService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "auth.PersonalInfoService",
	HandlerType: (*PersonalInfoServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetPersonalInfo",
			Handler:    _PersonalInfoService_GetPersonalInfo_Handler,
		},
		{
			MethodName: "UpdatePersonalInfo",
			Handler:    _PersonalInfoService_UpdatePersonalInfo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "auth.proto",
}

const (
	ProfilePhotoService_ListProfilePhotos_FullMethodName  = "/auth.ProfilePhotoService/ListProfilePhotos"
	ProfilePhotoService_UploadProfilePhoto_FullMethodName = "/auth.ProfilePhotoService/UploadProfilePhoto"
	ProfilePhotoService_GetProfilePhoto_FullMethodName    = "/auth.ProfilePhotoService/GetProfilePhoto"
	ProfilePhotoService_DeleteProfilePhoto_FullMethodName = "/auth.ProfilePhotoService/DeleteProfilePhoto"
)

// ProfilePhotoServiceClient is the client API for ProfilePhotoService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ProfilePhoto Service - handles user profile photo management
type ProfilePhotoServiceClient interface {
	ListProfilePhotos(ctx context.Context, in *ListProfilePhotosRequest, opts ...grpc.CallOption) (*ListProfilePhotosResponse, error)
	UploadProfilePhoto(ctx context.Context, in *UploadProfilePhotoRequest, opts ...grpc.CallOption) (*ProfilePhotoResponse, error)
	GetProfilePhoto(ctx context.Context, in *GetProfilePhotoRequest, opts ...grpc.CallOption) (*ProfilePhotoResponse, error)
	DeleteProfilePhoto(ctx context.Context, in *DeleteProfilePhotoRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type profilePhotoServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewProfilePhotoServiceClient(cc grpc.ClientConnInterface) ProfilePhotoServiceClient {
	return &profilePhotoServiceClient{cc}
}

func (c *profilePhotoServiceClient) ListProfilePhotos(ctx context.Context, in *ListProfilePhotosRequest, opts ...grpc.CallOption) (*ListProfilePhotosResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListProfilePhotosResponse)
	err := c.cc.Invoke(ctx, ProfilePhotoService_ListProfilePhotos_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *profilePhotoServiceClient) UploadProfilePhoto(ctx context.Context, in *UploadProfilePhotoRequest, opts ...grpc.CallOption) (*ProfilePhotoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProfilePhotoResponse)
	err := c.cc.Invoke(ctx, ProfilePhotoService_UploadProfilePhoto_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *profilePhotoServiceClient) GetProfilePhoto(ctx context.Context, in *GetProfilePhotoRequest, opts ...grpc.CallOption) (*ProfilePhotoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProfilePhotoResponse)
	err := c.cc.Invoke(ctx, ProfilePhotoService_GetProfilePhoto_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *profilePhotoServiceClient) DeleteProfilePhoto(ctx context.Context, in *DeleteProfilePhotoRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, ProfilePhotoService_DeleteProfilePhoto_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProfilePhotoServiceServer is the server API for ProfilePhotoService service.
// All implementations must embed UnimplementedProfilePhotoServiceServer
// for forward compatibility.
//
// ProfilePhoto Service - handles user profile photo management
type ProfilePhotoServiceServer interface {
	ListProfilePhotos(context.Context, *ListProfilePhotosRequest) (*ListProfilePhotosResponse, error)
	UploadProfilePhoto(context.Context, *UploadProfilePhotoRequest) (*ProfilePhotoResponse, error)
	GetProfilePhoto(context.Context, *GetProfilePhotoRequest) (*ProfilePhotoResponse, error)
	DeleteProfilePhoto(context.Context, *DeleteProfilePhotoRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedProfilePhotoServiceServer()
}

// UnimplementedProfilePhotoServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedProfilePhotoServiceServer struct{}

func (UnimplementedProfilePhotoServiceServer) ListProfilePhotos(context.Context, *ListProfilePhotosRequest) (*ListProfilePhotosResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListProfilePhotos not implemented")
}
func (UnimplementedProfilePhotoServiceServer) UploadProfilePhoto(context.Context, *UploadProfilePhotoRequest) (*ProfilePhotoResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UploadProfilePhoto not implemented")
}
func (UnimplementedProfilePhotoServiceServer) GetProfilePhoto(context.Context, *GetProfilePhotoRequest) (*ProfilePhotoResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetProfilePhoto not implemented")
}
func (UnimplementedProfilePhotoServiceServer) DeleteProfilePhoto(context.Context, *DeleteProfilePhotoRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteProfilePhoto not implemented")
}
func (UnimplementedProfilePhotoServiceServer) mustEmbedUnimplementedProfilePhotoServiceServer() {}
func (UnimplementedProfilePhotoServiceServer) testEmbeddedByValue()                             {}

// UnsafeProfilePhotoServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProfilePhotoServiceServer will
// result in compilation errors.
type UnsafeProfilePhotoServiceServer interface {
	mustEmbedUnimplementedProfilePhotoServiceServer()
}

func RegisterProfilePhotoServiceServer(s grpc.ServiceRegistrar, srv ProfilePhotoServiceServer) {
	// If the following call panics, it indicates UnimplementedProfilePhotoServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ProfilePhotoService_ServiceDesc, srv)
}

func _ProfilePhotoService_ListProfilePhotos_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListProfilePhotosRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProfilePhotoServiceServer).ListProfilePhotos(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProfilePhotoService_ListProfilePhotos_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProfilePhotoServiceServer).ListProfilePhotos(ctx, req.(*ListProfilePhotosRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProfilePhotoService_UploadProfilePhoto_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UploadProfilePhotoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProfilePhotoServiceServer).UploadProfilePhoto(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProfilePhotoService_UploadProfilePhoto_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProfilePhotoServiceServer).UploadProfilePhoto(ctx, req.(*UploadProfilePhotoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProfilePhotoService_GetProfilePhoto_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProfilePhotoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProfilePhotoServiceServer).GetProfilePhoto(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProfilePhotoService_GetProfilePhoto_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProfilePhotoServiceServer).GetProfilePhoto(ctx, req.(*GetProfilePhotoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProfilePhotoService_DeleteProfilePhoto_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteProfilePhotoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProfilePhotoServiceServer).DeleteProfilePhoto(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProfilePhotoService_DeleteProfilePhoto_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProfilePhotoServiceServer).DeleteProfilePhoto(ctx, req.(*DeleteProfilePhotoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ProfilePhotoService_ServiceDesc is the grpc.ServiceDesc for ProfilePhotoService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ProfilePhotoService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "auth.ProfilePhotoService",
	HandlerType: (*ProfilePhotoServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListProfilePhotos",
			Handler:    _ProfilePhotoService_ListProfilePhotos_Handler,
		},
		{
			MethodName: "UploadProfilePhoto",
			Handler:    _ProfilePhotoService_UploadProfilePhoto_Handler,
		},
		{
			MethodName: "GetProfilePhoto",
			Handler:    _ProfilePhotoService_GetProfilePhoto_Handler,
		},
		{
			MethodName: "DeleteProfilePhoto",
			Handler:    _ProfilePhotoService_DeleteProfilePhoto_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "auth.proto",
}

const (
	SettingsService_GetSettings_FullMethodName           = "/auth.SettingsService/GetSettings"
	SettingsService_UpdateSettings_FullMethodName        = "/auth.SettingsService/UpdateSettings"
	SettingsService_GetGeneralSettings_FullMethodName    = "/auth.SettingsService/GetGeneralSettings"
	SettingsService_UpdateGeneralSettings_FullMethodName = "/auth.SettingsService/UpdateGeneralSettings"
	SettingsService_GetPrivacySettings_FullMethodName    = "/auth.SettingsService/GetPrivacySettings"
	SettingsService_UpdatePrivacySettings_FullMethodName = "/auth.SettingsService/UpdatePrivacySettings"
)

// SettingsServiceClient is the client API for SettingsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Settings Service - handles user settings and preferences
type SettingsServiceClient interface {
	GetSettings(ctx context.Context, in *GetSettingsRequest, opts ...grpc.CallOption) (*GetSettingsResponse, error)
	UpdateSettings(ctx context.Context, in *UpdateSettingsRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetGeneralSettings(ctx context.Context, in *GetGeneralSettingsRequest, opts ...grpc.CallOption) (*GetGeneralSettingsResponse, error)
	UpdateGeneralSettings(ctx context.Context, in *UpdateGeneralSettingsRequest, opts ...grpc.CallOption) (*UpdateGeneralSettingsResponse, error)
	GetPrivacySettings(ctx context.Context, in *GetPrivacySettingsRequest, opts ...grpc.CallOption) (*GetPrivacySettingsResponse, error)
	UpdatePrivacySettings(ctx context.Context, in *UpdatePrivacySettingsRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type settingsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSettingsServiceClient(cc grpc.ClientConnInterface) SettingsServiceClient {
	return &settingsServiceClient{cc}
}

func (c *settingsServiceClient) GetSettings(ctx context.Context, in *GetSettingsRequest, opts ...grpc.CallOption) (*GetSettingsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSettingsResponse)
	err := c.cc.Invoke(ctx, SettingsService_GetSettings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *settingsServiceClient) UpdateSettings(ctx context.Context, in *UpdateSettingsRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, SettingsService_UpdateSettings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *settingsServiceClient) GetGeneralSettings(ctx context.Context, in *GetGeneralSettingsRequest, opts ...grpc.CallOption) (*GetGeneralSettingsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetGeneralSettingsResponse)
	err := c.cc.Invoke(ctx, SettingsService_GetGeneralSettings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *settingsServiceClient) UpdateGeneralSettings(ctx context.Context, in *UpdateGeneralSettingsRequest, opts ...grpc.CallOption) (*UpdateGeneralSettingsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateGeneralSettingsResponse)
	err := c.cc.Invoke(ctx, SettingsService_UpdateGeneralSettings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *settingsServiceClient) GetPrivacySettings(ctx context.Context, in *GetPrivacySettingsRequest, opts ...grpc.CallOption) (*GetPrivacySettingsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetPrivacySettingsResponse)
	err := c.cc.Invoke(ctx, SettingsService_GetPrivacySettings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *settingsServiceClient) UpdatePrivacySettings(ctx context.Context, in *UpdatePrivacySettingsRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, SettingsService_UpdatePrivacySettings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SettingsServiceServer is the server API for SettingsService service.
// All implementations must embed UnimplementedSettingsServiceServer
// for forward compatibility.
//
// Settings Service - handles user settings and preferences
type SettingsServiceServer interface {
	GetSettings(context.Context, *GetSettingsRequest) (*GetSettingsResponse, error)
	UpdateSettings(context.Context, *UpdateSettingsRequest) (*emptypb.Empty, error)
	GetGeneralSettings(context.Context, *GetGeneralSettingsRequest) (*GetGeneralSettingsResponse, error)
	UpdateGeneralSettings(context.Context, *UpdateGeneralSettingsRequest) (*UpdateGeneralSettingsResponse, error)
	GetPrivacySettings(context.Context, *GetPrivacySettingsRequest) (*GetPrivacySettingsResponse, error)
	UpdatePrivacySettings(context.Context, *UpdatePrivacySettingsRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedSettingsServiceServer()
}

// UnimplementedSettingsServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSettingsServiceServer struct{}

func (UnimplementedSettingsServiceServer) GetSettings(context.Context, *GetSettingsRequest) (*GetSettingsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSettings not implemented")
}
func (UnimplementedSettingsServiceServer) UpdateSettings(context.Context, *UpdateSettingsRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateSettings not implemented")
}
func (UnimplementedSettingsServiceServer) GetGeneralSettings(context.Context, *GetGeneralSettingsRequest) (*GetGeneralSettingsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetGeneralSettings not implemented")
}
func (UnimplementedSettingsServiceServer) UpdateGeneralSettings(context.Context, *UpdateGeneralSettingsRequest) (*UpdateGeneralSettingsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateGeneralSettings not implemented")
}
func (UnimplementedSettingsServiceServer) GetPrivacySettings(context.Context, *GetPrivacySettingsRequest) (*GetPrivacySettingsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetPrivacySettings not implemented")
}
func (UnimplementedSettingsServiceServer) UpdatePrivacySettings(context.Context, *UpdatePrivacySettingsRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdatePrivacySettings not implemented")
}
func (UnimplementedSettingsServiceServer) mustEmbedUnimplementedSettingsServiceServer() {}
func (UnimplementedSettingsServiceServer) testEmbeddedByValue()                         {}

// UnsafeSettingsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SettingsServiceServer will
// result in compilation errors.
type UnsafeSettingsServiceServer interface {
	mustEmbedUnimplementedSettingsServiceServer()
}

func RegisterSettingsServiceServer(s grpc.ServiceRegistrar, srv SettingsServiceServer) {
	// If the following call panics, it indicates UnimplementedSettingsServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SettingsService_ServiceDesc, srv)
}

func _SettingsService_GetSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettingsServiceServer).GetSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SettingsService_GetSettings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettingsServiceServer).GetSettings(ctx, req.(*GetSettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SettingsService_UpdateSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateSettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettingsServiceServer).UpdateSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SettingsService_UpdateSettings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettingsServiceServer).UpdateSettings(ctx, req.(*UpdateSettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SettingsService_GetGeneralSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGeneralSettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettingsServiceServer).GetGeneralSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SettingsService_GetGeneralSettings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettingsServiceServer).GetGeneralSettings(ctx, req.(*GetGeneralSettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SettingsService_UpdateGeneralSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateGeneralSettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettingsServiceServer).UpdateGeneralSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SettingsService_UpdateGeneralSettings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettingsServiceServer).UpdateGeneralSettings(ctx, req.(*UpdateGeneralSettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SettingsService_GetPrivacySettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPrivacySettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettingsServiceServer).GetPrivacySettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SettingsService_GetPrivacySettings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettingsServiceServer).GetPrivacySettings(ctx, req.(*GetPrivacySettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SettingsService_UpdatePrivacySettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatePrivacySettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettingsServiceServer).UpdatePrivacySettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SettingsService_UpdatePrivacySettings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettingsServiceServer).UpdatePrivacySettings(ctx, req.(*UpdatePrivacySettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SettingsService_ServiceDesc is the grpc.ServiceDesc for SettingsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SettingsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "auth.SettingsService",
	HandlerType: (*SettingsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetSettings",
			Handler:    _SettingsService_GetSettings_Handler,
		},
		{
			MethodName: "UpdateSettings",
			Handler:    _SettingsService_UpdateSettings_Handler,
		},
		{
			MethodName: "GetGeneralSettings",
			Handler:    _SettingsService_GetGeneralSettings_Handler,
		},
		{
			MethodName: "UpdateGeneralSettings",
			Handler:    _SettingsService_UpdateGeneralSettings_Handler,
		},
		{
			MethodName: "GetPrivacySettings",
			Handler:    _SettingsService_GetPrivacySettings_Handler,
		},
		{
			MethodName: "UpdatePrivacySettings",
			Handler:    _SettingsService_UpdatePrivacySettings_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "auth.proto",
}

const (
	UserEventsService_ListUserEvents_FullMethodName     = "/auth.UserEventsService/ListUserEvents"
	UserEventsService_GetUserEvent_FullMethodName       = "/auth.UserEventsService/GetUserEvent"
	UserEventsService_ReportUserEvent_FullMethodName    = "/auth.UserEventsService/ReportUserEvent"
	UserEventsService_SendReportResponse_FullMethodName = "/auth.UserEventsService/SendReportResponse"
	UserEventsService_CloseEventReport_FullMethodName   = "/auth.UserEventsService/CloseEventReport"
)

// UserEventsServiceClient is the client API for UserEventsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// UserEvents Service - handles user security events and reports
type UserEventsServiceClient interface {
	ListUserEvents(ctx context.Context, in *ListUserEventsRequest, opts ...grpc.CallOption) (*ListUserEventsResponse, error)
	GetUserEvent(ctx context.Context, in *GetUserEventRequest, opts ...grpc.CallOption) (*GetUserEventResponse, error)
	ReportUserEvent(ctx context.Context, in *ReportUserEventRequest, opts ...grpc.CallOption) (*UserEventReportResponse, error)
	SendReportResponse(ctx context.Context, in *SendReportResponseRequest, opts ...grpc.CallOption) (*UserEventReportResponseResponse, error)
	CloseEventReport(ctx context.Context, in *CloseEventReportRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type userEventsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserEventsServiceClient(cc grpc.ClientConnInterface) UserEventsServiceClient {
	return &userEventsServiceClient{cc}
}

func (c *userEventsServiceClient) ListUserEvents(ctx context.Context, in *ListUserEventsRequest, opts ...grpc.CallOption) (*ListUserEventsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListUserEventsResponse)
	err := c.cc.Invoke(ctx, UserEventsService_ListUserEvents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userEventsServiceClient) GetUserEvent(ctx context.Context, in *GetUserEventRequest, opts ...grpc.CallOption) (*GetUserEventResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUserEventResponse)
	err := c.cc.Invoke(ctx, UserEventsService_GetUserEvent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userEventsServiceClient) ReportUserEvent(ctx context.Context, in *ReportUserEventRequest, opts ...grpc.CallOption) (*UserEventReportResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserEventReportResponse)
	err := c.cc.Invoke(ctx, UserEventsService_ReportUserEvent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userEventsServiceClient) SendReportResponse(ctx context.Context, in *SendReportResponseRequest, opts ...grpc.CallOption) (*UserEventReportResponseResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserEventReportResponseResponse)
	err := c.cc.Invoke(ctx, UserEventsService_SendReportResponse_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userEventsServiceClient) CloseEventReport(ctx context.Context, in *CloseEventReportRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, UserEventsService_CloseEventReport_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserEventsServiceServer is the server API for UserEventsService service.
// All implementations must embed UnimplementedUserEventsServiceServer
// for forward compatibility.
//
// UserEvents Service - handles user security events and reports
type UserEventsServiceServer interface {
	ListUserEvents(context.Context, *ListUserEventsRequest) (*ListUserEventsResponse, error)
	GetUserEvent(context.Context, *GetUserEventRequest) (*GetUserEventResponse, error)
	ReportUserEvent(context.Context, *ReportUserEventRequest) (*UserEventReportResponse, error)
	SendReportResponse(context.Context, *SendReportResponseRequest) (*UserEventReportResponseResponse, error)
	CloseEventReport(context.Context, *CloseEventReportRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedUserEventsServiceServer()
}

// UnimplementedUserEventsServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserEventsServiceServer struct{}

func (UnimplementedUserEventsServiceServer) ListUserEvents(context.Context, *ListUserEventsRequest) (*ListUserEventsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListUserEvents not implemented")
}
func (UnimplementedUserEventsServiceServer) GetUserEvent(context.Context, *GetUserEventRequest) (*GetUserEventResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetUserEvent not implemented")
}
func (UnimplementedUserEventsServiceServer) ReportUserEvent(context.Context, *ReportUserEventRequest) (*UserEventReportResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReportUserEvent not implemented")
}
func (UnimplementedUserEventsServiceServer) SendReportResponse(context.Context, *SendReportResponseRequest) (*UserEventReportResponseResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SendReportResponse not implemented")
}
func (UnimplementedUserEventsServiceServer) CloseEventReport(context.Context, *CloseEventReportRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method CloseEventReport not implemented")
}
func (UnimplementedUserEventsServiceServer) mustEmbedUnimplementedUserEventsServiceServer() {}
func (UnimplementedUserEventsServiceServer) testEmbeddedByValue()                           {}

// UnsafeUserEventsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserEventsServiceServer will
// result in compilation errors.
type UnsafeUserEventsServiceServer interface {
	mustEmbedUnimplementedUserEventsServiceServer()
}

func RegisterUserEventsServiceServer(s grpc.ServiceRegistrar, srv UserEventsServiceServer) {
	// If the following call panics, it indicates UnimplementedUserEventsServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserEventsService_ServiceDesc, srv)
}

func _UserEventsService_ListUserEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListUserEventsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserEventsServiceServer).ListUserEvents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserEventsService_ListUserEvents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserEventsServiceServer).ListUserEvents(ctx, req.(*ListUserEventsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserEventsService_GetUserEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserEventRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserEventsServiceServer).GetUserEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserEventsService_GetUserEvent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserEventsServiceServer).GetUserEvent(ctx, req.(*GetUserEventRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserEventsService_ReportUserEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportUserEventRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserEventsServiceServer).ReportUserEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserEventsService_ReportUserEvent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserEventsServiceServer).ReportUserEvent(ctx, req.(*ReportUserEventRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserEventsService_SendReportResponse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendReportResponseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserEventsServiceServer).SendReportResponse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserEventsService_SendReportResponse_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserEventsServiceServer).SendReportResponse(ctx, req.(*SendReportResponseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserEventsService_CloseEventReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloseEventReportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserEventsServiceServer).CloseEventReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserEventsService_CloseEventReport_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserEventsServiceServer).CloseEventReport(ctx, req.(*CloseEventReportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// UserEventsService_ServiceDesc is the grpc.ServiceDesc for UserEventsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserEventsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "auth.UserEventsService",
	HandlerType: (*UserEventsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListUserEvents",
			Handler:    _UserEventsService_ListUserEvents_Handler,
		},
		{
			MethodName: "GetUserEvent",
			Handler:    _UserEventsService_GetUserEvent_Handler,
		},
		{
			MethodName: "ReportUserEvent",
			Handler:    _UserEventsService_ReportUserEvent_Handler,
		},
		{
			MethodName: "SendReportResponse",
			Handler:    _UserEventsService_SendReportResponse_Handler,
		},
		{
			MethodName: "CloseEventReport",
			Handler:    _UserEventsService_CloseEventReport_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "auth.proto",
}

const (
	SearchService_SearchUsers_FullMethodName     = "/auth.SearchService/SearchUsers"
	SearchService_SearchFeatures_FullMethodName  = "/auth.SearchService/SearchFeatures"
	SearchService_SearchIsicCodes_FullMethodName = "/auth.SearchService/SearchIsicCodes"
)

// SearchServiceClient is the client API for SearchService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ============== Search Service ==============
// Search Service - handles search endpoints (no authentication required)
type SearchServiceClient interface {
	SearchUsers(ctx context.Context, in *SearchUsersRequest, opts ...grpc.CallOption) (*SearchUsersResponse, error)
	SearchFeatures(ctx context.Context, in *SearchFeaturesRequest, opts ...grpc.CallOption) (*SearchFeaturesResponse, error)
	SearchIsicCodes(ctx context.Context, in *SearchIsicCodesRequest, opts ...grpc.CallOption) (*SearchIsicCodesResponse, error)
}

type searchServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSearchServiceClient(cc grpc.ClientConnInterface) SearchServiceClient {
	return &searchServiceClient{cc}
}

func (c *searchServiceClient) SearchUsers(ctx context.Context, in *SearchUsersRequest, opts ...grpc.CallOption) (*SearchUsersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SearchUsersResponse)
	err := c.cc.Invoke(ctx, SearchService_SearchUsers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchServiceClient) SearchFeatures(ctx context.Context, in *SearchFeaturesRequest, opts ...grpc.CallOption) (*SearchFeaturesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SearchFeaturesResponse)
	err := c.cc.Invoke(ctx, SearchService_SearchFeatures_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchServiceClient) SearchIsicCodes(ctx context.Context, in *SearchIsicCodesRequest, opts ...grpc.CallOption) (*SearchIsicCodesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SearchIsicCodesResponse)
	err := c.cc.Invoke(ctx, SearchService_SearchIsicCodes_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SearchServiceServer is the server API for SearchService service.
// All implementations must embed UnimplementedSearchServiceServer
// for forward compatibility.
//
// ============== Search Service ==============
// Search Service - handles search endpoints (no authentication required)
type SearchServiceServer interface {
	SearchUsers(context.Context, *SearchUsersRequest) (*SearchUsersResponse, error)
	SearchFeatures(context.Context, *SearchFeaturesRequest) (*SearchFeaturesResponse, error)
	SearchIsicCodes(context.Context, *SearchIsicCodesRequest) (*SearchIsicCodesResponse, error)
	mustEmbedUnimplementedSearchServiceServer()
}

// UnimplementedSearchServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSearchServiceServer struct{}

func (UnimplementedSearchServiceServer) SearchUsers(context.Context, *SearchUsersRequest) (*SearchUsersResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SearchUsers not implemented")
}
func (UnimplementedSearchServiceServer) SearchFeatures(context.Context, *SearchFeaturesRequest) (*SearchFeaturesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SearchFeatures not implemented")
}
func (UnimplementedSearchServiceServer) SearchIsicCodes(context.Context, *SearchIsicCodesRequest) (*SearchIsicCodesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SearchIsicCodes not implemented")
}
func (UnimplementedSearchServiceServer) mustEmbedUnimplementedSearchServiceServer() {}
func (UnimplementedSearchServiceServer) testEmbeddedByValue()                       {}

// UnsafeSearchServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SearchServiceServer will
// result in compilation errors.
type UnsafeSearchServiceServer interface {
	mustEmbedUnimplementedSearchServiceServer()
}

func RegisterSearchServiceServer(s grpc.ServiceRegistrar, srv SearchServiceServer) {
	// If the following call panics, it indicates UnimplementedSearchServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SearchService_ServiceDesc, srv)
}

func _SearchService_SearchUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchUsersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServiceServer).SearchUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SearchService_SearchUsers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServiceServer).SearchUsers(ctx, req.(*SearchUsersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SearchService_SearchFeatures_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchFeaturesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServiceServer).SearchFeatures(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SearchService_SearchFeatures_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServiceServer).SearchFeatures(ctx, req.(*SearchFeaturesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SearchService_SearchIsicCodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchIsicCodesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServiceServer).SearchIsicCodes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SearchService_SearchIsicCodes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServiceServer).SearchIsicCodes(ctx, req.(*SearchIsicCodesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SearchService_ServiceDesc is the grpc.ServiceDesc for SearchService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SearchService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "auth.SearchService",
	HandlerType: (*SearchServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SearchUsers",
			Handler:    _SearchService_SearchUsers_Handler,
		},
		{
			MethodName: "SearchFeatures",
			Handler:    _SearchService_SearchFeatures_Handler,
		},
		{
			MethodName: "SearchIsicCodes",
			Handler:    _SearchService_SearchIsicCodes_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "auth.proto",
}
